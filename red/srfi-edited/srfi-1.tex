\section{List library}

\redno{1} The small language has a basic set of list-processing
utilities. The large language extends this set substantially.

\setlibname{list}

\TODO{Some of these procedures duplicate those of the small
  language. Do we want that?}

\TODO{Define “linear update” and “pure functional” procedures. I
  assume that other SRFIs use the same terms, so maybe in a
  “Definitions” section in the introduction?}

\subsection{{Procedure Index}}\label{procedure-index}

\TODO{I think this whole section can be deleted. There are a few
  comments here about how a procedure in this library extends one in
  Scheme-small. Those should probably be folded into the descriptions
  of the individual procedures.}

Here is a short list of the procedures provided.

\begin{description}
\item[ Constructors ]

\begin{verbatim}
cons list
xcons cons* make-list list-tabulate 
list-copy circular-list iota
\end{verbatim}
\item[ Predicates ]
\begin{verbatim}
pair? null?
proper-list? circular-list? dotted-list? 
not-pair? null-list?
list=
\end{verbatim}
\item[ Selectors ]
\begin{verbatim}
car cdr ... cddadr cddddr list-ref
first second third fourth fifth 
sixth seventh eighth ninth tenth
car+cdr
take       drop
take-right drop-right
take!      drop-right! 
split-at   split-at! 
last last-pair
\end{verbatim}
\item[ Miscellaneous: length, append, concatenate, reverse, zip \& count
]
\begin{verbatim}
length length+
append  concatenate  reverse
append! concatenate! reverse!
append-reverse append-reverse!
zip unzip1 unzip2 unzip3 unzip4 unzip5
count
\end{verbatim}
\item[ Fold, unfold \& map ]
\begin{verbatim}
map for-each
fold       unfold       pair-fold       
fold-right unfold-right pair-fold-right 
reduce  reduce-right 
append-map append-map!
map! pair-for-each filter-map map-in-order
\end{verbatim}
\item[ Filtering \& partitioning ]
\begin{verbatim}
filter  partition  remove
filter! partition! remove! 
\end{verbatim}
\item[ Searching ]
\begin{verbatim}
member memq memv
find find-tail 
any every
list-index
take-while drop-while take-while!
span break span! break!
\end{verbatim}
\item[ Deleting ]
\begin{verbatim}
delete  delete-duplicates 
delete! delete-duplicates!
\end{verbatim}
\item[ Association lists ]
\begin{verbatim}
assoc assq assv
alist-cons alist-copy
alist-delete alist-delete!
\end{verbatim}
\item[ Set operations on lists ]
\begin{verbatim}
lset<= lset= lset-adjoin
lset-union             lset-union!
lset-intersection      lset-intersection!
lset-difference        lset-difference!
lset-xor               lset-xor!
lset-diff+intersection lset-diff+intersection!
\end{verbatim}
\item[ Primitive side-effects ]
\begin{verbatim}
set-car! set-cdr!
\end{verbatim}
\end{description}

Four R4RS/R5RS list-processing procedures are
extended by this library in backwards-compatible ways:

\begin{tabular}{ll}
\texttt{map for-each} & Extended to take lists of unequal length \\
\texttt{member assoc} & Extended to take an optional comparison \\
                      & procedure.
\end{tabular}

The following R4RS/R5RS list- and
pair-processing procedures are also part of list-lib's exports, as
defined by the R5RS:

\begin{verbatim}
cons pair? null?
car cdr ... cdddar cddddr 
set-car! set-cdr! 
list append reverse
length list-ref
memq memv assq assv
\end{verbatim}

The remaining two R4RS/R5RS list-processing
procedures are \emph{not} part of this library:

\begin{tabular}{ll}
\texttt{list-tail} & renamed \texttt{drop}\\
\texttt{list?} & see \texttt{proper-list?}, \texttt{circular-list?}\\
               & and \texttt{dotted-list?}
\end{tabular}

The linear-update procedures in this library are

\texttt{ take! drop-right! split-at! append! concatenate! reverse!
  append-reverse! append-map! map! filter! partition! remove!
  take-while! span! break! delete! alist-delete! delete-duplicates!
  lset-adjoin! lset-union! lset-intersection!  lset-difference!
  lset-xor! lset-diff+intersection!} 

\subsection{{Improper Lists}}\label{improper-lists}

Scheme does not properly have a list type, just as C does not have a
string type. Rather, Scheme has a binary-tuple type, from which one can
build binary trees. There is an \emph{interpretation} of Scheme values
that allows one to treat these trees as lists. Further complications
ensue from the fact that Scheme allows side-effects to these tuples,
raising the possibility of lists of unbounded length, and trees of
unbounded depth (that is, circular data structures).

However, there is a simple view of the world of Scheme values that
considers every value to be a list of some sort. that is, every value is
either

\begin{itemize}
\tightlist
\item
  a ``proper list'' -- a finite, nil-terminated list, such as:\\
  \texttt{(a\ b\ c)}\\
  \texttt{()}\\
  \texttt{(32)}\\
\item
  a ``dotted list'' -- a finite, non-nil terminated list, such as:\\
  \texttt{(a\ b\ c\ .\ d)}\\
  \texttt{(x\ .\ y)}\\
  \texttt{42}\\
  \texttt{george}\\
\item
  or a ``circular list'' -- an infinite, unterminated list.
\end{itemize}

Note that the zero-length dotted lists are simply all the non-null,
non-pair values.

This view is captured by the predicates \texttt{proper-list?},
\texttt{dotted-list?}, and \texttt{circular-list?}. List-lib users
should note that dotted lists are not commonly used, and are considered
by many Scheme programmers to be an ugly artifact of Scheme's lack of a
true list type. However, dotted lists do play a noticeable role in the
\emph{syntax} of Scheme, in the ``rest'' parameters used by n-ary
lambdas: \texttt{(lambda\ (x\ y\ .\ rest)\ ...)}.

Dotted lists are \emph{not} fully supported by list-lib. Most procedures
are defined only on proper lists -- that is, finite, nil-terminated
lists. The procedures that will also handle circular or dotted lists are
specifically marked. While this design decision restricts the domain of
possible arguments one can pass to these procedures, it has the benefit
of allowing the procedures to catch the error cases where programmers
inadvertently pass scalar values to a list procedure by accident,
\emph{e.g.}, by switching the arguments to a procedure call.

\subsection{{Errors}}

\TODO{Rewrite this section so it matches R$^7$RS. Ideally, nothing
  additional regarding errors should need to appear in this Report,
  because the error language should match R$^7$RS.} 

Note that statements of the form ``it is an error'' merely mean ``don't
do that.'' They are not a guarantee that a conforming implementation
will ``catch'' such improper use by, for example, raising some kind of
exception. Regrettably, R5RS Scheme requires
no firmer guarantee even for basic operators such as \texttt{car} and
\texttt{cdr}, so there's little point in requiring these procedures to
do more. Here is the relevant section of the
R5RS:

\begin{quote}
When speaking of an error situation, this report uses the phrase ``an
error is signalled'' to indicate that implementations must detect and
report the error. If such wording does not appear in the discussion of
an error, then implementations are not required to detect or report the
error, though they are encouraged to do so. An error situation that
implementations are not required to detect is usually referred to simply
as ``an error.''

For example, it is an error for a procedure to be passed an argument
that the procedure is not explicitly specified to handle, even though
such domain errors are seldom mentioned in this report. Implementations
may extend a procedure's domain of definition to include such arguments.
\end{quote}


\subsection{Notation}

\TODO{Move this to the beginning of the Report, as part of a
  standardized “Notation” section, and reformat. Check that these
  notations are consistent with those in R$^7$RS.}

\begin{tabular}{ll}
list & A proper (finite, nil-terminated) list\\
clist & A proper or circular list\\
flist & A finite (proper or dotted) list\\
pair & A pair\\
x, y, d, a & Any value\\
object, value & Any value\\
n, i & A natural number (an integer \textgreater{}= 0)\\
proc & A procedure\\
pred & A procedure whose return value is treated\\
     & as a boolean\\
= & A boolean procedure taking two arguments\\
\end{tabular}

It is an error to pass a circular or dotted list to a procedure not
defined to accept such an argument.

\subsection{{Constructors}}\label{constructors}

\begin{entry}{%
    \Proto{cons}{ a d}{procedure}{pair}}

    The primitive
    constructor. Returns a newly allocated pair whose car is a and
    whose cdr is d. The pair is guaranteed to be different (in the
    sense of \texttt{eqv?}) from every existing object.

\begin{verbatim}
(cons 'a '())        => (a)
(cons '(a) '(b c d)) => ((a) b c d)
(cons "a" '(b c))    => ("a" b c)
(cons 'a 3)          => (a . 3)
(cons '(a b) 'c)     => ((a b) . c)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{list}{ object \ldots}{procedure}{list}}

  Returns a newly allocated list of its arguments.

\begin{verbatim}
(list 'a (+ 3 4) 'c) =>  (a 7 c)
(list)               =>  ()
\end{verbatim}
\end{entry}

\begin{entry}{%
    \Proto{xcons}{ d a}{procedure}{pair}}
\begin{verbatim}
(lambda (d a) (cons a d))
\end{verbatim}

  Of utility only as a value to be conveniently passed to higher-order
  procedures.

\begin{verbatim}
(xcons '(b c) 'a) => (a b c)
\end{verbatim}

  The name stands for ``eXchanged CONS.'' 
\end{entry}

\begin{entry}{%
  \Proto{cons*}{ elt$_1$ elt$_2$ \ldots}{procedure}{object}}
  
  Like \texttt{list}, but the last
  argument provides the tail of the constructed list, returning

  \texttt{\ (cons\ elt1\ (cons\ elt2\ (cons\ ...\ eltn)))\ \ \ \ \ }

  This function is called \texttt{list*} in
  {Common Lisp} and about half of the
  Schemes that provide it, and \texttt{cons*} in the other half.
\begin{verbatim}
(cons* 1 2 3 4) => (1 2 3 . 4)
(cons* 1) => 1
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{make-list}{ n fill}{procedure}{list}
  \Rproto{make-list}{ n}{procedure}{list}}
  
  Returns an n-element list, whose elements are all the value fill. If
  the fill argument is not given, the elements of the list may be
  arbitrary values.

\begin{verbatim}
(make-list 4 'c) => (c c c c)
\end{verbatim}
\end{entry}


\begin{entry}{%
  \Proto{list-tabulate}{ n init-proc}{procedure}{list}}
  
  Returns an n-element list. Element i of the list, where $0≤\textrm{i}≤\textrm{n}$,
    is produced by \texttt{(init-proc\
    i)}. No guarantee is made about the dynamic order in which
  init-proc is applied to these indices.

\begin{verbatim}
(list-tabulate 4 values) => (0 1 2 3)
\end{verbatim}

\end{entry}


\begin{entry}{%
  \Proto{list-copy}{ flist}{procedure}{flist}}

  Copies the
  spine of the argument. \TODO{More detail.} 
\end{entry}

\begin{entry}{%
  \Proto{circular-list}{ elt$_1$ elt$_2$ \ldots}{procedure}{list}}
  
  Constructs a circular list of the
  elements.

\begin{verbatim}
(circular-list 'z 'q) => (z q z q z q ...)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iota}{ count start step}{procedure}{list}
  \Rproto{iota}{ count}{procedure}{list}}

  Returns a list containing the elements

\begin{verbatim}
(start start+step ... start+(count-1)*step)
\end{verbatim}

  The start and step parameters default to 0 and 1, respectively. This
  procedure takes its name from the APL primitive.

\begin{verbatim}
(iota 5) => (0 1 2 3 4)
(iota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)
\end{verbatim}
\end{entry}

\subsection{{Predicates}}

Note: the predicates \texttt{proper-list?}, \texttt{circular-list?}, and
\texttt{dotted-list?} partition the entire universe of Scheme values.

  \begin{entry}{%
    \Proto{proper-list?}{ x}{procedure}{boolean}}
    Returns
    true iff x is a proper list -- a finite, nil-terminated list.

    \TODO{I'm not sure where this stuff should go. Maybe at the
      beginning of the section?}

    More carefully: The empty list is a proper list. A pair whose cdr
    is a proper list is also a proper list:

\begin{verbatim}
<proper-list> ::= ()                            (Empty proper list)
              |   (cons <x> <proper-list>)      (Proper-list pair)
\end{verbatim}

    Note that this definition rules out circular lists. This function
    is required to detect this case and return false.

    Nil-terminated lists are called ``proper'' lists by R5RS and
    Common Lisp. The opposite of proper is improper.

    R5RS binds this function to the variable
    \texttt{list?}.
    
\begin{verbatim}
(not (proper-list? x)) = (or (dotted-list? x) (circular-list? x))
\end{verbatim}
 
  \TODO{This needs to be rewritten; definitions should be moved to a
    “Definitions” section at the front.}

  \end{entry}

  \begin{entry}{%
      \Proto{circular-list?}{ x}{procedure}{boolean}} 
 
    True if x
    is a circular list. A circular list is a value such that for every
    n \textgreater{}= 0, cdr\textsuperscript{n}(x) is a pair.

    Terminology: The opposite of circular is finite.

\begin{verbatim}
(not (circular-list? x)) = (or (proper-list? x) (dotted-list? x))
\end{verbatim}
  \end{entry}

  \begin{entry}{%
      \Proto{dotted-list?}{ x}{procedure}{boolean}}

    True if x is
    a finite, non-nil-terminated list. That is, there exists an n
    \textgreater{}= 0 such that cdr\textsuperscript{n}(x) is neither a
    pair nor (). This includes non-pair, non-() values (\emph{e.g.}
    symbols, numbers), which are considered to be dotted lists of
    length 0.

\begin{verbatim}
(not (dotted-list? x)) = (or (proper-list? x) (circular-list? x))
\end{verbatim}

  \end{entry}

  \begin{entry}{%
      \Proto{pair?}{ object}{procedure}{boolean}}

     Returns \texttt{\#t} if object is a
    pair; otherwise, \texttt{\#f}.

\begin{verbatim}
(pair? '(a . b)) =>  #t
(pair? '(a b c)) =>  #t
(pair? '())      =>  #f
(pair? '#(a b))  =>  #f
(pair? 7)        =>  #f
(pair? 'a)       =>  #f
\end{verbatim}
  \end{entry}

  \begin{entry}{%
      \Proto{null?}{ object}{procedure}{boolean}}

    Returns \texttt{\#t} if object is the
    empty list; otherwise, \texttt{\#f}.
  \end{entry}

  \begin{entry}{%
      \Proto{null-list?}{ list}{procedure}{boolean}}

    list is a
    proper or circular list. This procedure returns true if the
    argument is the empty list (), and false otherwise. It is an error
    to pass this procedure a value which is not a proper or circular
    list. This procedure is recommended as the termination condition
    for list-processing procedures that are not defined on dotted
    lists.
  \end{entry}

  \begin{entry}{%
      \Proto{not-pair?}{ x}{procedure}{boolean}}

\begin{verbatim}
(lambda (x) (not (pair? x)))
\end{verbatim}

    Provided as a procedure as it can be useful as the termination
    condition for list-processing procedures that wish to handle all
    finite lists, both proper and dotted.
  \end{entry}

  \begin{entry}{%
      \Proto{list=}{ elt$_1$ elt$_2$ \ldots}{procedure}{boolean}}

     Determines list equality, given an
    element-equality procedure. Proper list A equals proper list B if
    they are of the same length, and their corresponding elements are
    equal, as determined by elt=. If the element-comparison
    procedure's first argument is from list\textsubscript{i}, then its
    second argument is from list\textsubscript{i+1}, \emph{i.e.} it is
    always called as \texttt{(elt=\ a\ b)} for a an element of list A,
    and b an element of list B.

    In the n-ary case, every list\textsubscript{i} is compared to
    list\textsubscript{i+1} (as opposed, for example, to comparing
    list\textsubscript{1} to every list\textsubscript{i}, for
    i\textgreater{}1). If there are no list arguments at all,
    \texttt{list=} simply returns true.

    It is an error to apply \texttt{list=} to anything except proper
    lists.  While implementations may choose to extend it to circular
    lists, note that it cannot reasonably be extended to dotted lists,
    as it provides no way to specify an equality procedure for
    comparing the list terminators.

    Note that the dynamic order in which the elt= procedure is applied
    to pairs of elements is not specified. For example, if
    \texttt{list=} is applied to three lists, A, B, and C, it may
    first completely compare A to B, then compare B to C, or it may
    compare the first elements of A and B, then the first elements of
    B and C, then the second elements of A and B, and so forth.

    The equality procedure must be consistent with \texttt{eq?}. That
    is, it must be the case that

    \texttt{(eq?\ x\ y)} =\textgreater{} \texttt{(elt=\ x\ y)}.

    Note that this implies that two lists which are \texttt{eq?} are
    always list=, as well; implementations may exploit this fact to
    ``short-cut'' the element-by-element comparisons.

\begin{verbatim}
(list= eq?) => #t       ; Trivial cases
(list= eq? '(a)) => #t
\end{verbatim}
  \end{entry}

\subsection{{Selectors}}\label{selectors}

\begin{entry}{%
    \Proto{car}{ pair}{procedure}{boolean}
    \Proto{cdr}{ pair}{procedure}{boolean}}

  These functions
  return the contents of the car and cdr field of their argument,
  respectively. Note that it is an error to apply them to the empty
  list.

\begin{verbatim}
(car '(a b c))     =>  a         (cdr '(a b c))     =>  (b c)  
(car '((a) b c d)) =>  (a)       (cdr '((a) b c d)) =>  (b c d)
(car '(1 . 2))     =>  1         (cdr '(1 . 2))     =>  2      
(car '())          =>  *error*   (cdr '())          =>  *error*
\end{verbatim}
\end{entry}
   
\begin{entry}{%
  \Proto{caar}{ pair}{procedure}{boolean}
  \Proto{cadr}{ pair}{procedure}{boolean}
  \texttt{:}\\
  \Proto{cdddar}{ pair}{procedure}{boolean}
  \Proto{cddddr}{ pair}{procedure}{boolean}}

  These
  procedures are compositions of \texttt{car} and \texttt{cdr}, where
  for example \texttt{caddr} could be defined by

\begin{verbatim}
(define caddr (lambda (x) (car (cdr (cdr x))))).
\end{verbatim}

  Arbitrary compositions, up to four deep, are provided. There are
  twenty-eight of these procedures in all.
\end{entry}

\begin{entry}{%
  \Proto{list-ref}{ clist i}{procedure}{value}}

  Returns the i\textsuperscript{th} element of clist. (This is the
  same as the car of \texttt{(drop\ clist\ i)}.) It is an error if i
  \textgreater{}= n, where n is the length of clist.

\begin{verbatim}
(list-ref '(a b c d) 2) => c
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{first}{ pair}{procedure}{value}
  \Proto{second}{ pair}{procedure}{value}
  \Proto{third}{ pair}{procedure}{value}
  \Proto{fourth}{ pair}{procedure}{value}
  \Proto{fifth}{ pair}{procedure}{value}
  \Proto{sixth}{ pair}{procedure}{value}
  \Proto{seventh}{ pair}{procedure}{value}
  \Proto{eighth}{ pair}{procedure}{value}
  \Proto{nineth}{ pair}{procedure}{value}
  \Proto{tenth}{ pair}{procedure}{value}}

 Synonyms for
  \texttt{car}, \texttt{cadr}, \texttt{caddr}, \ldots{}

\begin{verbatim}
(third '(a b c d e)) => c
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{car+cdr}{ pair}{procedure}{x y}}

  Returns the car and cdr of pair as two values.

\begin{verbatim}
(lambda (p) (values (car p) (cdr p)))
\end{verbatim}

  This can, of course, be implemented more efficiently by a compiler.
\end{entry}

\begin{entry}{%
  \Proto{take}{ x i}{procedure}{list}
  \Proto{drop}{ x i}{procedure}{object}}

  \texttt{take} returns the first i elements of list x.\\
  \texttt{drop} returns all but the first i elements of list x.

\begin{verbatim}
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
\end{verbatim}

  x may be any value -- a proper, circular, or dotted list:

\begin{verbatim}
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(take '(1 2 3 . d) 3) => (1 2 3)
(drop '(1 2 3 . d) 3) => d
\end{verbatim}

  For a legal i, \texttt{take} and \texttt{drop} partition the list in
  a manner which can be inverted with \texttt{append}:

\begin{verbatim}
(append (take x i) (drop x i)) = x
\end{verbatim}

  \texttt{drop} is exactly equivalent to performing i cdr operations
  on x; the returned value shares a common tail with x. If the
  argument is a list of non-zero length, \texttt{take} is guaranteed
  to return a freshly-allocated list, even in the case where the
  entire list is taken, \emph{e.g.} \texttt{(take\ lis\ (length\
    lis))}.
\end{entry}


\begin{entry}{%
  \Proto{take-right}{ flist i}{procedure}{object}
  \Proto{drop-right}{ flist i}{procedure}{list}}

  \texttt{take-right} returns the last i elements of flist.\\
  \texttt{drop-right} returns all but the last i elements of flist.

\begin{verbatim}
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
\end{verbatim}

  The returned list may share a common tail with the argument list.

  flist may be any finite list, either proper or dotted:

\begin{verbatim}
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
\end{verbatim}

  For a legal i, \texttt{take-right} and \texttt{drop-right} partition
  the list in a manner which can be inverted with \texttt{append}:

\begin{verbatim}
(append (take flist i) (drop flist i)) = flist
\end{verbatim}

  \texttt{take-right}'s return value is guaranteed to share a common
  tail with flist. If the argument is a list of non-zero length,
  \texttt{drop-right} is guaranteed to return a freshly-allocated
  list, even in the case where nothing is dropped, \emph{e.g.}
  \texttt{(drop-right\ lis\ 0)}.
\end{entry}

\begin{entry}{%
  \Proto{take!}{ x i}{procedure}{list}
  \Proto{drop-right!}{ flist i}{procedure}{list}}

\texttt{take!}  and \texttt{drop-right!} are ``linear-update''
variants of \texttt{take} and \texttt{drop-right}: the procedure is
allowed, but not required, to alter the argument list to produce the
result.

  If x is circular, \texttt{take!} may return a shorter-than-expected
  list:

\begin{verbatim}
(take! (circular-list 1 3 5) 8) => (1 3)
(take! (circular-list 1 3 5) 8) => (1 3 5 1 3 5 1 3)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{split-at}{ x i}{procedure}{list object}
  \Proto{split-at!}{ x i}{procedure}{list object}}

  \texttt{split-at} splits the list x at index i, returning a list of
  the first i elements, and the remaining tail. It is equivalent to

\begin{verbatim}
(values (take x i) (drop x i))
\end{verbatim}

  \texttt{split-at!} is the linear-update variant. It is allowed, but
  not required, to alter the argument list to produce the result.

\begin{verbatim}
(split-at '(a b c d e f g h) 3) =>
    (a b c)
    (d e f g h)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{last}{ pair}{procedure}{object}
  \Proto{last-pair}{ pair}{procedure}{pair}}

  \texttt{last} returns
  the last element of the non-empty, finite list
  pair. \texttt{last-pair} returns the last pair in the non-empty,
  finite list pair.

\begin{verbatim}
(last '(a b c)) => c
(last-pair '(a b c)) => (c)
\end{verbatim}
\end{entry}


\subsection{{Miscellaneous}}


\begin{entry}{%
  \Proto{length}{ list}{procedure}{integer}
  \Proto{length+}{ list}{procedure}{integer \rm{or} \schfalse}}

   Both
  \texttt{length} and \texttt{length+} return the length of the
  argument. It is an error to pass a value to \texttt{length} which is
  not a proper list (finite and nil-terminated). In particular, this
  means an implementation may diverge or signal an error when
  \texttt{length} is applied to a circular list.

  \texttt{length+}, on the other hand, returns \texttt{\#F} when
  applied to a circular list.

  The length of a proper list is a non-negative integer n such that
  \texttt{cdr} applied n times to the list produces the empty list.
\end{entry}

\begin{entry}{%
  \Proto{append}{ list$_1$ \ldots}{procedure}{list}
  \Proto{append!}{ list$_1$ \ldots}{procedure}{list}}

  \texttt{append} returns a list consisting of the
  elements of list\textsubscript{1} followed by the elements of the
  other list parameters.

\begin{verbatim}
(append '(x) '(y))        =>  (x y)
(append '(a) '(b c d))    =>  (a b c d)
(append '(a (b)) '((c)))  =>  (a (b) (c))
\end{verbatim}

  The resulting list is always newly allocated, except that it shares
  structure with the final list\textsubscript{i} argument. This last
  argument may be any value at all; an improper list results if it is
  not a proper list. All other arguments must be proper lists.

\begin{verbatim}
(append '(a b) '(c . d))  =>  (a b c . d)
(append '() 'a)           =>  a
(append '(x y))           =>  (x y)
(append)                  =>  ()
\end{verbatim}

  \texttt{append!} is the ``linear-update'' variant of \texttt{append}
  -- it is allowed, but not required, to alter cons cells in the
  argument lists to construct the result list. The last argument is
  never altered; the result list shares structure with this parameter.
\end{entry}

\begin{entry}{%
    \Proto{concatenate}{ list-of-lists}{procedure}{value}
    \Proto{concatenate!}{ list-of-lists}{procedure}{value}}

  These
  functions append the elements of their argument together. That is,
  \texttt{concatenate} returns

\begin{verbatim}
(apply append list-of-lists)
\end{verbatim}

  or, equivalently,

\begin{verbatim}
(reduce-right append '() list-of-lists)
\end{verbatim}

  \texttt{concatenate!} is the linear-update variant, defined in terms
  of \texttt{append!} instead of \texttt{append}.

  Note that some Scheme implementations do not support passing more
  than a certain number (\emph{e.g.}, 64) of arguments to an n-ary
  procedure. In these implementations, the \texttt{(apply\ append\
    ...)} idiom would fail when applied to long lists, but
  \texttt{concatenate} would continue to function properly.

  As with \texttt{append} and \texttt{append!}, the last element of
  the input list may be any value at all.
\end{entry}

\begin{entry}{%
  \Proto{reverse}{ list}{procedure}{list}
  \Proto{reverse!}{ list}{procedure}{list}}

  \texttt{reverse} returns a newly allocated list consisting of the
  elements of list in reverse order.

\begin{verbatim}
(reverse '(a b c)) =>  (c b a)
(reverse '(a (b c) d (e (f))))
    =>  ((e (f)) d (b c) a)
\end{verbatim}

  \texttt{reverse!} is the linear-update variant of
  \texttt{reverse}. It is permitted, but not required, to alter the
  argument's cons cells to produce the reversed list.
\end{entry}

\begin{entry}{%
  \Proto{append-reverse}{ rev-head tail}{procedure}{list}
  \Proto{append-reverse!}{ rev-head tail}{procedure}{list}}

  \texttt{append-reverse} returns \texttt{(append\ (reverse\
    rev-head)\ tail)}. It is provided because it is a common operation
  -- a common list-processing style calls for this exact operation to
  transfer values accumulated in reverse order onto the front of
  another list, and because the implementation is significantly more
  efficient than the simple composition it replaces. (But note that
  this pattern of iterative computation followed by a reverse can
  frequently be rewritten as a recursion, dispensing with the
  \texttt{reverse} and \texttt{append-reverse} steps, and shifting
  temporary, intermediate storage from the heap to the stack, which is
  typically a win for reasons of cache locality and eager storage
  reclamation.)

  \texttt{append-reverse!} is just the linear-update variant -- it is
  allowed, but not required, to alter rev-head's cons cells to
  construct the result.
\end{entry}

\begin{entry}{%
  \Proto{zip}{ clist$_1$ clist$_2$ \ldots}{procedure}{list}}

\begin{verbatim}
(lambda lists (apply map list lists))
\end{verbatim}

  If \texttt{zip} is passed n lists, it returns a list as long as the
  shortest of these lists, each element of which is an n-element list
  comprised of the corresponding elements from the parameter lists.

\begin{verbatim}
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
    => ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) => ((1) (2) (3))
\end{verbatim}

  At least one of the argument lists must be finite:

\begin{verbatim}
(zip '(3 1 4 1) (circular-list #f #t)) 
    => ((3 #f) (1 #t) (4 #f) (1 #t))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{unzip1}{ list}{procedure}{list}
  \Proto{unzip2}{ list}{procedure}{list list}
  \Proto{unzip3}{ list}{procedure}{list list list}
  \Proto{unzip4}{ list}{procedure}{list list list list}
  \Proto{unzip5}{ list}{procedure}{list list list list list}}

  \texttt{unzip1} takes a list of lists, where every list must
  contain at least one element, and returns a list containing the
  initial element of each such list. That is, it returns \texttt{(map\
    car\ lists)}.  \texttt{unzip2} takes a list of lists, where every
  list must contain at least two elements, and returns two values: a
  list of the first elements, and a list of the second
  elements. \texttt{unzip3} does the same for the first three elements
  of the lists, and so forth.

\begin{verbatim}
(unzip2 '((1 one) (2 two) (3 three))) =>
    (1 2 3) 
    (one two three)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{count}{ clist$_1$ clist$_2$ \ldots}{procedure}{integer}}

  \TODO{The ellipsis wasn't present in the original. Is this a
    mistake?} 

  pred is a procedure
  taking as many arguments as there are lists and returning a single
  value. It is applied element-wise to the elements of the lists, and
  a count is tallied of the number of elements that produce a true
  value. This count is returned. \texttt{count} is ``iterative'' in
  that it is guaranteed to apply pred to the list elements in a
  left-to-right order. The counting stops when the shortest list
  expires.

\begin{verbatim}
(count even? '(3 1 4 1 5 9 2 5 6)) => 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) => 3
\end{verbatim}

  At least one of the argument lists must be finite:

\begin{verbatim}
(count < '(3 1 4 1) (circular-list 1 10)) => 2
\end{verbatim}
\end{entry}


\subsection{{Fold, unfold, and map}}

\begin{entry}{%
  \Proto{fold}{ kons knil clist$_1$ clist$_2$
    \ldots}{procedure}{value}}

  The
  fundamental list iterator.

  First, consider the single list-parameter case. If
  clist\textsubscript{1} = (e\textsubscript{1} e\textsubscript{2}
  \ldots{} e\textsubscript{n}), then this procedure returns

  \texttt{(kons\ en\ ...\ (kons\ e2\ (kons\ e1\ knil))\ ...\ )}

  That is, it obeys the (tail) recursion

\begin{verbatim}
(fold kons knil lis) = (fold kons (kons (car lis) knil) (cdr lis))
(fold kons knil '()) = knil
\end{verbatim}

  Examples:

\begin{verbatim}
(fold + 0 lis)          ; Add up the elements of LIS.

(fold cons '() lis)     ; Reverse LIS.

(fold cons tail rev-head)   ; See APPEND-REVERSE.

;; How many symbols in LIS?
(fold (lambda (x count) (if (symbol? x) (+ count 1) count))
      0
      lis)

;; Length of the longest string in LIS:
(fold (lambda (s max-len) (max max-len (string-length s)))
      0
      lis)
\end{verbatim}

  If n list arguments are provided, then the kons function must take
  n+1 parameters: one element from each list, and the ``seed'' or fold
  state, which is initially knil. The fold operation terminates when
  the shortest list runs out of values:

\begin{verbatim}
(fold cons* '() '(a b c) '(1 2 3 4 5)) => (c 3 b 2 a 1)
\end{verbatim}

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{fold-right}{ kons knil clist$_1$ clist$_2$ \ldots}{procedure}{value}}

  The  fundamental list recursion operator.

  First, consider the single list-parameter case. If
  clist\textsubscript{1} = \texttt{(e1\ e2\ ...\ en)}, then this
  procedure returns

  \texttt{\ (kons\ e1\ (kons\ e2\ ...\ (kons\ en\ knil)))}

  That is, it obeys the recursion

\begin{verbatim}
(fold-right kons knil lis) = (kons (car lis) (fold-right kons knil (cdr lis)))
(fold-right kons knil '()) = knil
\end{verbatim}

  Examples:

\begin{verbatim}
(fold-right cons '() lis)       ; Copy LIS.

;; Filter the even numbers out of LIS.
(fold-right (lambda (x l) (if (even? x) (cons x l) l)) '() lis))
\end{verbatim}

  If n list arguments are provided, then the kons function must take
  n+1 parameters: one element from each list, and the ``seed'' or fold
  state, which is initially knil. The fold operation terminates when
  the shortest list runs out of values:

\begin{verbatim}
(fold-right cons* '() '(a b c) '(1 2 3 4 5)) => (a 1 b 2 c 3)
\end{verbatim}

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{pair-fold}{ kons knil clist$_1$ clist$_2$ \ldots}{procedure}{value}}

  Analogous to
  \texttt{fold}, but kons is applied to successive sublists of the
  lists, rather than successive elements -- that is, kons is applied
  to the pairs making up the lists, giving this (tail) recursion:

\begin{verbatim}
(pair-fold kons knil lis) = (let ((tail (cdr lis)))
                              (pair-fold kons (kons lis knil) tail))
(pair-fold kons knil '()) = knil
\end{verbatim}

  For finite lists, the kons function may reliably apply
  \texttt{set-cdr!}  to the pairs it is given without altering the
  sequence of execution.

  Example:

\begin{verbatim}
;;; Destructively reverse a list.
(pair-fold (lambda (pair tail) (set-cdr! pair tail) pair) '() lis))
\end{verbatim}

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{pair-fold-right}{ kons knil clist$_1$ clist$_2$ \ldots}{procedure}{value}}

  Holds the
  same relationship with \texttt{fold-right} that \texttt{pair-fold}
  holds with \texttt{fold}. Obeys the recursion

\begin{verbatim}
(pair-fold-right kons knil lis) = 
    (kons lis (pair-fold-right kons knil (cdr lis)))
(pair-fold-right kons knil '()) = knil
\end{verbatim}

  Example:

\begin{verbatim}
(pair-fold-right cons '() '(a b c)) => ((a b c) (b c) (c))
\end{verbatim}

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{reduce}{ f ridentity list}{procedure}{value}}

  \texttt{reduce} is a variant of \texttt{fold}.

  ridentity should be a ``right identity'' of the procedure f -- that
  is, for any value x acceptable to f,

\begin{verbatim}
(f x ridentity) = x
\end{verbatim}

  \texttt{reduce} has the following definition:

  If list = (), return ridentity;\\
  Otherwise, return \texttt{(fold\ f\ (car\ list)\ (cdr\ list))}.

  \ldots{}in other words, we compute \texttt{(fold\ f\ ridentity\
    list)}.

  Note that ridentity is used \emph{only} in the empty-list case. You
  typically use \texttt{reduce} when applying f is expensive and you'd
  like to avoid the extra application incurred when \texttt{fold}
  applies f to the head of list and the identity value, redundantly
  producing the same value passed in to f. For example, if f involves
  searching a file directory or performing a database query, this can
  be significant. In general, however, \texttt{fold} is useful in many
  contexts where \texttt{reduce} is not (consider the examples given
  in the \texttt{fold} definition -- only one of the five folds uses a
  function with a right identity. The other four may not be performed
  with \texttt{reduce}).

  Note: MIT Scheme and Haskell flip F's arg order for their
  \texttt{reduce} and \texttt{fold} functions.

\begin{verbatim}
;; Take the max of a list of non-negative integers.
(reduce max 0 nums) ; i.e., (apply max 0 nums)
\end{verbatim}
\end{entry}


\begin{entry}{%
  \Proto{reduce-right}{ f ridentity list}{procedure}{value}}

  \texttt{reduce-right} is the fold-right variant of
  \texttt{reduce}. It obeys the following definition:

\begin{verbatim}
(reduce-right f ridentity '()) = ridentity
(reduce-right f ridentity '(e1)) = (f e1 ridentity) = e1
(reduce-right f ridentity '(e1 e2 ...)) =
    (f e1 (reduce f ridentity (e2 ...)))
\end{verbatim}

  \ldots{}in other words, we compute \texttt{(fold-right\ f\
    ridentity\ list)}.

\begin{verbatim}
;; Append a bunch of lists together.
;; I.e., (apply append list-of-lists)
(reduce-right append '() list-of-lists)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{unfold}{ p f g seed tail-gen}{procedure}{list}
  \Rproto{unfold}{ p f g seed}{procedure}{list}}

 \texttt{unfold} is best described by its basic recursion:

\begin{verbatim}
(unfold p f g seed) = 
    (if (p seed) (tail-gen seed)
        (cons (f seed)
              (unfold p f g (g seed))))
\end{verbatim}

\begin{description}
  \tightlist
\item[ p ] Determines when to stop unfolding.
\item[ f ] Maps each seed value to the corresponding list element.
\item[ g ] Maps each seed value to next seed value.
\item[ seed ] The ``state'' value for the unfold.
\item[ tail-gen ] Creates the tail of the list; defaults to
  \texttt{(lambda\ (x)\ \textquotesingle{}())}
\end{description}

In other words, we use g to generate a sequence of seed values

seed, g(seed), g\textsuperscript{2}(seed), g\textsuperscript{3}(seed),
\ldots{}

These seed values are mapped to list elements by f, producing the
elements of the result list in a left-to-right order. P says when to
stop.

\texttt{unfold} is the fundamental recursive list constructor, just as
\texttt{fold-right} is the fundamental recursive list consumer. While
\texttt{unfold} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

\begin{verbatim}
;; List of squares: 1^2 ... 10^2
(unfold (lambda (x) (> x 10))
        (lambda (x) (* x x))
    (lambda (x) (+ x 1))
    1)
        
(unfold null-list? car cdr lis) ; Copy a proper list.

;; Read current input port into a list of values.
(unfold eof-object? values (lambda (x) (read)) (read))

;; Copy a possibly non-proper list:
(unfold not-pair? car cdr lis 
              values)

;; Append HEAD onto TAIL:
(unfold null-list? car cdr head 
              (lambda (x) tail))
\end{verbatim}

Interested functional programmers may enjoy noting that
\texttt{fold-right} and \texttt{unfold} are in some sense
inverses. That is, given operations knull?, kar, kdr, kons, and knil
satisfying

\texttt{(kons\ (kar\ x)\ (kdr\ x))} = \texttt{x} and \texttt{(knull?\
  knil)} = \texttt{\#t}

then

\texttt{(fold-right\ kons\ knil\ (unfold\ knull?\ kar\ kdr\ x))} = x

and

\texttt{(unfold\ knull?\ kar\ kdr\ (fold-right\ kons\ knil\ x))} = x.

This combinator sometimes is called an ``anamorphism;'' when an
explicit tail-gen procedure is supplied, it is called an
``apomorphism.''
\end{entry}

\begin{entry}{%
  \Proto{unfold-right}{ p f g seed tail}{procedure}{list}
  \Rproto{unfold-right}{ p f g seed}{procedure}{list}}

  \texttt{unfold-right} constructs a list with the following
  loop:

\begin{verbatim}
(let lp ((seed seed) (lis tail))
  (if (p seed) lis
      (lp (g seed)
          (cons (f seed) lis))))
\end{verbatim}

\begin{description}
  \tightlist
\item[ p ] Determines when to stop unfolding.
\item[ f ] Maps each seed value to the corresponding list element.
\item[ g ] Maps each seed value to next seed value.
\item[ seed ] The ``state'' value for the unfold.
\item[ tail ] list terminator; defaults to
  \texttt{\textquotesingle{}()}.
\end{description}

In other words, we use g to generate a sequence of seed values

seed, g(seed), g\textsuperscript{2}(seed), g\textsuperscript{3}(seed),
\ldots{}

These seed values are mapped to list elements by f, producing the
elements of the result list in a right-to-left order. P says when to
stop.

\texttt{unfold-right} is the fundamental iterative list constructor,
just as \texttt{fold} is the fundamental iterative list
consumer. While \texttt{unfold-right} may seem a bit abstract to
novice functional programmers, it can be used in a number of ways:

\begin{verbatim}
;; List of squares: 1^2 ... 10^2
(unfold-right zero? 
              (lambda (x) (* x x))
              (lambda (x) (- x 1))
              10)
    
;; Reverse a proper list.
(unfold-right null-list? car cdr lis)

;; Read current input port into a list of values.
(unfold-right eof-object? values (lambda (x) (read)) (read))

;; (append-reverse rev-head tail)
(unfold-right null-list? car cdr rev-head tail)
\end{verbatim}

Interested functional programmers may enjoy noting that \texttt{fold}
and \texttt{unfold-right} are in some sense inverses. That is, given
operations knull?, kar, kdr, kons, and knil satisfying

\texttt{(kons\ (kar\ x)\ (kdr\ x))} = \texttt{x} and \texttt{(knull?\
  knil)} = \texttt{\#t}

then

\texttt{(fold\ kons\ knil\ (unfold-right\ knull?\ kar\ kdr\ x))} = x

and

\texttt{(unfold-right\ knull?\ kar\ kdr\ (fold\ kons\ knil\ x))} = x.

\st{This combinator presumably has some pretentious mathematical name;
  interested readers are invited to communicate it to the author.}
\TODO{Do we want to say anything about this?}
\end{entry}

\begin{entry}{%
  \Proto{map}{ proc clist$_1$ clist$_2$ \ldots}{procedure}{list}}

  proc is a procedure taking as many arguments as
  there are list arguments and returning a single value.  \texttt{map}
  applies proc element-wise to the elements of the lists and returns a
  list of the results, in order. The dynamic order in which proc is
  applied to the elements of the lists is unspecified.

\begin{verbatim}
(map cadr '((a b) (d e) (g h))) =>  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))
    =>  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6)) =>  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b))) =>  (1 2) or (2 1)
\end{verbatim}

  This procedure is extended from its R5RS specification to allow the
  arguments to be of unequal length; it terminates when the shortest
  list runs out.

  At least one of the argument lists must be finite:

\begin{verbatim}
(map + '(3 1 4 1) (circular-list 1 0)) => (4 1 5 1)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{for-each}{ proc clist$_1$ clist$_2$ \ldots}{procedure}{unspecified}}

  {[}R5RS+{]} The arguments to
  \texttt{for-each} are like the arguments to \texttt{map}, but
  \texttt{for-each} calls proc for its side effects rather than for
  its values. Unlike \texttt{map}, \texttt{for-each} is guaranteed to
  call proc on the elements of the lists in order from the first
  element(s) to the last, and the value returned by \texttt{for-each}
  is unspecified.

\begin{verbatim}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)  =>  #(0 1 4 9 16)
\end{verbatim}

  This procedure is extended from its R5RS specification to allow the
  arguments to be of unequal length; it terminates when the shortest
  list runs out.

  At least one of the argument lists must be finite.
\end{entry}

\begin{entry}{%
  \Proto{append-map}{ f clist$_1$ clist$_2$ \ldots}{procedure}{value}
  \Proto{append-map!}{ f clist$_1$ clist$_2$ \ldots}{procedure}{value}}

  Equivalent to

  \texttt{\ (apply\ append\ \ (map\ f\ clist1\ clist2\ ...))}

  and

  \texttt{\ (apply\ append!\ (map\ f\ clist1\ clist2\ ...))}

  Map f over the elements of the lists, just as in the \texttt{map}
  function. However, the results of the applications are appended
  together to make the final result. \texttt{append-map} uses
  \texttt{append} to append the results together; \texttt{append-map!}
  uses \texttt{append!}.

  The dynamic order in which the various applications of f are made is
  not specified.

  Example:

\begin{verbatim}
(append-map! (lambda (x) (list x (- x))) '(1 3 8))
    => (1 -1 3 -3 8 -8)
\end{verbatim}

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{map!}{ f list$_1$ clist$_2$ \ldots}{procedure}{list}}

  Linear-update variant of \texttt{map} -- \texttt{map!} is
  allowed, but not required, to alter the cons cells of list$_1$ to
  construct the result list.

  The dynamic order in which the various applications of f are made is
  not specified. In the n-ary case, clist$_2$, clist$_3$, \ldots{}
  must have at least as many elements as list$_1$.
\end{entry}

\begin{entry}{%
  \Proto{map-in-order}{ f clist$_1$ clist$_2$ \ldots}{procedure}{list}}

  A variant of the \texttt{map} procedure that
  guarantees to apply f across the elements of the
  list\textsubscript{i} arguments in a left-to-right order. This is
  useful for mapping procedures that both have side effects and return
  useful values.

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{pair-for-each}{ f clist$_1$ clist$_2$ \ldots}{procedure}{unspecific}}

  \TODO{I think the above should be “unspecified”, but in the original
    it says “unspecific”. Correct?}

  Like \texttt{for-each}, but f is
  applied to successive sublists of the argument lists. That is, f is
  applied to the cons cells of the lists, rather than the lists'
  elements. These applications occur in left-to-right order.

  The f procedure may reliably apply \texttt{set-cdr!} to the pairs it
  is given without altering the sequence of execution.

\begin{verbatim}
(pair-for-each (lambda (pair) (display pair) (newline)) '(a b c)) ==>
    (a b c)
    (b c)
    (c)
\end{verbatim}

  At least one of the list arguments must be finite.
\end{entry}

\begin{entry}{%
  \Proto{filter-map}{ f clist$_1$ clist$_2$ \ldots}{procedure}{list}}

  Like \texttt{map}, but only true values are
  saved.

\begin{verbatim}
(filter-map (lambda (x) (and (number? x) (* x x))) '(a 1 b 3 c 7))
    => (1 9 49)
\end{verbatim}

  The dynamic order in which the various applications of f are made is
  not specified.

  At least one of the list arguments must be finite.
\end{entry}

\subsection{Filtering and partitioning}
\TODO{introduction}

\begin{entry}{%
  \Proto{filter}{ pred list}{procedure}{list}}
 
  Return all the
  elements of list that satisfy predicate pred. The list is not
  disordered -- elements that appear in the result list occur in the
  same order as they occur in the argument list. The returned list may
  share a common tail with the argument list. The dynamic order in
  which the various applications of pred are made is not specified.

\begin{verbatim}
(filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{partition}{ pred list}{procedure}{list list}}

  Partitions the elements of list with predicate pred, and returns two
  values: the list of in-elements and the list of out-elements. The
  list is not disordered -- elements occur in the result lists in the
  same order as they occur in the argument list. The dynamic order in
  which the various applications of pred are made is not
  specified. One of the returned lists may share a common tail with
  the argument list.

\begin{verbatim}
(partition symbol? '(one 2 3 four five 6)) => 
    (one four five)
    (2 3 6)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{remove}{ pred list}{procedure}{list}}

  Returns list
  without the elements that satisfy predicate pred:

\begin{verbatim}
(lambda (pred list) (filter (lambda (x) (not (pred x))) list))
\end{verbatim}

  The list is not disordered -- elements that appear in the result
  list occur in the same order as they occur in the argument list. The
  returned list may share a common tail with the argument list. The
  dynamic order in which the various applications of pred are made is
  not specified.

\begin{verbatim}
(remove even? '(0 7 8 8 43 -4)) => (7 43)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{filter!}{ pred list}{procedure}{list}
  \Proto{partition!}{ pred list}{procedure}{list list}
  \Proto{remove!}{ pred list}{procedure}{list}}

  Linear-update
  variants of \texttt{filter}, \texttt{partition} and
  \texttt{remove}. These procedures are allowed, but not required, to
  alter the cons cells in the argument list to construct the result
  lists.
\end{entry}

\subsection{{Searching}}\label{Searching}

\TODO{reorganize this introductory material, some of it belongs in the
  procedure entries.}

The following procedures all search lists for a leftmost element
satisfying some criteria. This means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list. Here are the
general rules describing how these procedures work when applied to
different kinds of lists:

\begin{description}
\tightlist
\item[ Proper lists: ]
The standard, canonical behavior happens in this case.
\item[ Dotted lists: ]
It is an error to pass these procedures a dotted list that does not
contain an element satisfying the search criteria. That is, it is an
error if the procedure has to search all the way to the end of the
dotted list. However, this SRFI does \emph{not} specify anything at all
about the behavior of these procedures when passed a dotted list
containing an element satisfying the search criteria. It may finish
successfully, signal an error, or perform some third action. Different
implementations may provide different functionality in this case; code
which is compliant with this SRFI may not rely on any particular
behavior. Future SRFI's may refine SRFI-1 to define specific behavior in
this case.

In brief, SRFI-1 compliant code may not pass a dotted list argument to
these procedures.
\item[ Circular lists: ]
It is an error to pass these procedures a circular list that does not
contain an element satisfying the search criteria. Note that the
procedure is not required to detect this case; it may simply diverge. It
is, however, acceptable to search a circular list \emph{if the search is
successful} -- that is, if the list contains an element satisfying the
search criteria.
\end{description}

Here are some examples, using the \texttt{find} and \texttt{any}
procedures as canonical representatives:

\begin{verbatim}
;; Proper list -- success
(find even? '(1 2 3))   => 2
(any  even? '(1 2 3))   => #t

;; proper list -- failure
(find even? '(1 7 3))   => #f
(any  even? '(1 7 3))   => #f

;; Failure is error on a dotted list.
(find even? '(1 3 . x)) => error
(any  even? '(1 3 . x)) => error

;; The dotted list contains an element satisfying the search.
;; This case is not specified -- it could be success, an error, 
;; or some third possibility.
(find even? '(1 2 . x)) => error/undefined
(any  even? '(1 2 . x)) => error/undefined ; success, error or other.

;; circular list -- success
(find even? (circular-list 1 6 3)) => 6
(any  even? (circular-list 1 6 3)) => #t

;; circular list -- failure is error. Procedure may diverge.
(find even? (circular-list 1 3)) => error
(any  even? (circular-list 1 3)) => error
\end{verbatim}

\begin{entry}{%
  \Proto{find}{ pred clist}{procedure}{value}}

  Return the
  first element of clist that satisfies predicate pred; false if no
  element does.

\begin{verbatim}
(find even? '(3 1 4 1 5 9)) => 4
\end{verbatim}

  Note that \texttt{find} has an ambiguity in its lookup semantics --
  if \texttt{find} returns \texttt{\#f}, you cannot tell (in general)
  if it found a \texttt{\#f} element that satisfied pred, or if it did
  not find any element at all. In many situations, this ambiguity
  cannot arise -- either the list being searched is known not to
  contain any \texttt{\#f} elements, or the list is guaranteed to have
  an element satisfying pred.  However, in cases where this ambiguity
  can arise, you should use \texttt{find-tail} instead of
  \texttt{find} -- \texttt{find-tail} has no such ambiguity:

\begin{verbatim}
(cond ((find-tail pred lis) => (lambda (pair) ...)) ; Handle (CAR PAIR)
      (else ...)) ; Search failed.
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{find-tail}{ pred clist}{procedure}{pair \textrm{or} \schfalse}}

  Return the first pair of clist whose car satisfies pred. If no pair
  does, return false.

  \texttt{find-tail} can be viewed as a general-predicate variant of
  the \texttt{member} function.

  Examples:

\begin{verbatim}
(find-tail even? '(3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
(find-tail even? '(3 1 37 -5)) => #f

;; MEMBER X LIS:
(find-tail (lambda (elt) (equal? x elt)) lis)
\end{verbatim}

  In the circular-list case, this procedure ``rotates'' the list.

  \texttt{Find-tail} is essentially \texttt{drop-while}, where the
  sense of the predicate is inverted: \texttt{Find-tail} searches
  until it finds an element satisfying the predicate;
  \texttt{drop-while} searches until it finds an element that
  \emph{doesn't} satisfy the predicate.
\end{entry}

\begin{entry}{%
  \Proto{take-while}{ pred clist}{procedure}{list}
  \Proto{take-while!}{ pred clist}{procedure}{list}}

  Returns the
  longest initial prefix of clist whose elements all satisfy the
  predicate pred.

  \texttt{Take-while!} is the linear-update variant. It is allowed,
  but not required, to alter the argument list to produce the result.

\begin{verbatim}
(take-while even? '(2 18 3 10 22 9)) => (2 18)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{drop-while}{ pred clist}{procedure}{list}}

  Drops the
  longest initial prefix of clist whose elements all satisfy the
  predicate pred, and returns the rest of the list.

\begin{verbatim}
(drop-while even? '(2 18 3 10 22 9)) => (3 10 22 9)
\end{verbatim}

  The circular-list case may be viewed as ``rotating'' the list.
\end{entry}

\begin{entry}{%
  \Proto{span}{ pred clist}{procedure}{list clist}
  \Proto{span!}{ pred list}{procedure}{list list}
  \Proto{break}{ pred clist}{procedure}{list clist}
  \Proto{break!}{ pred list}{procedure}{list list}}

  \texttt{span} splits the list into the longest initial prefix whose
  elements all satisfy pred, and the remaining tail. \texttt{break}
  inverts the sense of the predicate: the tail commences with the
  first element of the input list that satisfies the predicate.

  In other words: \texttt{span} finds the intial span of elements
  satisfying pred, and \texttt{break} breaks the list at the first
  element satisfying pred.

  \texttt{span} is equivalent to

\begin{verbatim}
(values (take-while pred clist) 
        (drop-while pred clist))
\end{verbatim}

  \texttt{span!} and \texttt{break!} are the linear-update
  variants. They are allowed, but not required, to alter the argument
  list to produce the result.

\begin{verbatim}
(span even? '(2 18 3 10 22 9)) =>
  (2 18)
  (3 10 22 9)

(break even? '(3 1 4 1 5 9)) =>
  (3 1)
  (4 1 5 9)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{any}{ pred clist$_1$ clist$_2$ \ldots}{procedure}{value}}

  Applies the predicate across the lists, returning true \TODO{\schtrue?} if
  the predicate returns true on any application.

  If there are n list arguments clist$_1$ \ldots{}
  clist\textsubscript{n}, then pred must be a procedure taking n
  arguments and returning a single value, interpreted as a boolean
  (that is, \texttt{\#f} means false, and any other value means true).

  \texttt{any} applies pred to the first elements of the
  clist\textsubscript{i} parameters. If this application returns a
  true value, \texttt{any} immediately returns that value. Otherwise,
  it iterates, applying pred to the second elements of the
  clist\textsubscript{i} parameters, then the third, and so forth. The
  iteration stops when a true value is produced or one of the lists
  runs out of values; in the latter case, \texttt{any} returns
  \texttt{\#f}.  The application of pred to the last element of the
  lists is a tail call.

  Note the difference between \texttt{find} and \texttt{any} --
  \texttt{find} returns the element that satisfied the predicate;
  \texttt{any} returns the true value that the predicate produced.

  Like \texttt{every}, \texttt{any}'s name does not end with a
  question mark -- this is to indicate that it does not return a
  simple boolean (\texttt{\#t} or \texttt{\#f}), but a general value.

\begin{verbatim}
(any integer? '(a 3 b 2.7))   => #t
(any integer? '(a 3.1 b 2.7)) => #f
(any < '(3 1 4 1 5)
       '(2 7 1 8 2)) => #t
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{every}{ pred clist$_1$ clist$_2$ \ldots}{procedure}{value}}

  Applies the predicate across the lists,
  returning true if the predicate returns true on every application.

  If there are n list arguments clist$_1$ \ldots{}
  clist\textsubscript{n}, then pred must be a procedure taking n
  arguments and returning a single value, interpreted as a boolean
  (that is, \texttt{\#f} means false, and any other value means true).

  \texttt{every} applies pred to the first elements of the
  clist\textsubscript{i} parameters. If this application returns
  false, \texttt{every} immediately returns false. Otherwise, it
  iterates, applying pred to the second elements of the
  clist\textsubscript{i} parameters, then the third, and so forth. The
  iteration stops when a false value is produced or one of the lists
  runs out of values. In the latter case, \texttt{every} returns the
  true value produced by its final application of pred. The
  application of pred to the last element of the lists is a tail call.

  If one of the clist\textsubscript{i} has no elements, \texttt{every}
  simply returns \texttt{\#t}.

  Like \texttt{any}, \texttt{every}'s name does not end with a
  question mark -- this is to indicate that it does not return a
  simple boolean (\texttt{\#t} or \texttt{\#f}), but a general value.
\end{entry}

\begin{entry}{%
  \Proto{list-index}{ pred clist$_1$ clist$_2$}{procedure}{integer or \schfalse}}

  Return the index of the leftmost
  element that satisfies pred.

  If there are n list arguments clist$_1$ \ldots{}
  clist\textsubscript{n}, then pred must be a function taking n
  arguments and returning a single value, interpreted as a boolean
  (that is, \texttt{\#f} means false, and any other value means true).

  \texttt{list-index} applies pred to the first elements of the
  clist\textsubscript{i} parameters. If this application returns true,
  \texttt{list-index} immediately returns zero. Otherwise, it
  iterates, applying pred to the second elements of the
  clist\textsubscript{i} parameters, then the third, and so
  forth. When it finds a tuple of list elements that cause pred to
  return true, it stops and returns the zero-based index of that
  position in the lists.

  The iteration stops when one of the lists runs out of values; in
  this case, \texttt{list-index} returns \texttt{\#f}.

\begin{verbatim}
(list-index even? '(3 1 4 1 5 9)) => 2
(list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => 1
(list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => #f
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{member}{ x list =}{procedure}{list}
  \Rproto{member}{ x list}{procedure}{list}
  \Proto{memq}{ x list}{procedure}{list}
  \Proto{memv}{ x list}{procedure}{list}}

  {[}R5RS+{]}   These
  procedures return the first sublist of list whose car is x, where
  the sublists of list are the non-empty lists returned by
  \texttt{(drop\ list\ i)} for i less than the length of list. If x
  does not occur in list, then \texttt{\#f} is returned. \texttt{memq}
  uses \texttt{eq?} to compare x with the elements of list, while
  \texttt{memv} uses \texttt{eqv?}, and \texttt{member} uses
  \texttt{equal?}.

\begin{verbatim}
    (memq 'a '(a b c))          =>  (a b c)
    (memq 'b '(a b c))          =>  (b c)
    (memq 'a '(b c d))          =>  #f
    (memq (list 'a) '(b (a) c)) =>  #f
    (member (list 'a)
            '(b (a) c))         =>  ((a) c)
    (memq 101 '(100 101 102))   =>  *unspecified*
    (memv 101 '(100 101 102))   =>  (101 102)
\end{verbatim}

  \texttt{member} is extended from its R5RS definition to allow the
  client to pass in an optional equality procedure = used to compare
  keys.

  The comparison procedure is used to compare the elements
  e\textsubscript{i} of list to the key x in this way:

  \texttt{\ (=\ x\ ei)\ \ \ \ \ \ \ ;\ list\ is\ (E1\ ...\ En)}

  That is, the first argument is always x, and the second argument is
  one of the list elements. Thus one can reliably find the first
  element of list that is greater than five with \texttt{(member\ 5\
    list\ \textless{})}

  Note that fully general list searching may be performed with the
  \texttt{find-tail} and \texttt{find} procedures, \emph{e.g.}

\begin{verbatim}
(find-tail even? list) ; Find the first elt with an even key.
\end{verbatim}
\end{entry}

\subsection{{Deletion}}

\begin{entry}{%
  \Proto{delete}{ x list =}{procedure}{list} 
  \Rproto{delete}{ x list}{procedure}{list} 
  \Proto{delete!}{ x list =}{procedure???}{list} 
  \Rproto{delete!}{ x list}{procedure???}{list}}

  \texttt{delete} uses the comparison
  procedure =, which defaults to \texttt{equal?}, to find all elements
  of list that are equal to x, and deletes them from list. The dynamic
  order in which the various applications of = are made is not
  specified.

  The list is not disordered -- elements that appear in the result
  list occur in the same order as they occur in the argument list. The
  result may share a common tail with the argument list.

  Note that fully general element deletion can be performed with the
  \texttt{remove} and \texttt{remove!} procedures, \emph{e.g.}:

\begin{verbatim}
;; Delete all the even elements from LIS:
(remove even? lis)
\end{verbatim}

  The comparison procedure is used in this way: \texttt{(=\ x\
    ei)}. That is, x is always the first argument, and a list element
  is always the second argument. The comparison procedure will be used
  to compare each element of list exactly once; the order in which it
  is applied to the various e\textsubscript{i} is not specified. Thus,
  one can reliably remove all the numbers greater than five from a
  list with \texttt{(delete\ 5\ list\ \textless{})}

  \texttt{delete!} is the linear-update variant of \texttt{delete}. It
  is allowed, but not required, to alter the cons cells in its
  argument list to construct the result.
\end{entry}

\begin{entry}{%
  \Proto{delete-duplicates}{ list =}{procedure}{list}
  \Rproto{delete-duplicates}{ list}{procedure}{list}
  \Proto{delete-duplicates!}{ list =}{procedure}{list}
  \Rproto{delete-duplicates!}{ list}{procedure}{list}}

  \texttt{delete-duplicates} removes duplicate elements from the list
  argument. If there are multiple equal elements in the argument list,
  the result list only contains the first or leftmost of these
  elements in the result. The order of these surviving elements is the
  same as in the original list -- \texttt{delete-duplicates} does not
  disorder the list (hence it is useful for ``cleaning up''
  association lists).

  The = parameter is used to compare the elements of the list; it
  defaults to \texttt{equal?}. If x comes before y in list, then the
  comparison is performed \texttt{(=\ x\ y)}. The comparison procedure
  will be used to compare each pair of elements in list no more than
  once; the order in which it is applied to the various pairs is not
  specified.

  Implementations of \texttt{delete-duplicates} are allowed to share
  common tails between argument and result lists -- for example, if
  the list argument contains only unique elements, it may simply
  return exactly this list.

  Be aware that, in general, \texttt{delete-duplicates} runs in time
  O(n\textsuperscript{2}) for n-element lists. Uniquifying long lists
  can be accomplished in O(n lg n) time by sorting the list to bring
  equal elements together, then using a linear-time algorithm to
  remove equal elements. Alternatively, one can use algorithms based
  on element-marking, with linear-time results.

  \texttt{delete-duplicates!} is the linear-update variant of
  \texttt{delete-duplicates}; it is allowed, but not required, to
  alter the cons cells in its argument list to construct the result.

\begin{verbatim}
(delete-duplicates '(a b a c a b c z)) => (a b c z)

;; Clean up an alist:
(delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                   (lambda (x y) (eq? (car x) (car y))))
    => ((a . 3) (b . 7) (c . 1))
\end{verbatim}
\end{entry}

\subsection{{Association lists}}

An ``association list'' (or ``alist'') is a list of pairs. The car of
each pair contains a key value, and the cdr contains the associated data
value. They can be used to construct simple look-up tables in Scheme.
Note that association lists are probably inappropriate for
performance-critical use on large data; in these cases, hash tables or
some other alternative should be employed.

\begin{entry}{%
  \Proto{assoc}{ key alist =}{procedure}{pair or \#f}
  \Rproto{assoc}{ key alist}{procedure}{pair or \#f}
  \Proto{assq}{ key alist}{procedure}{pair or \#f}
  \Proto{assv}{ key alist}{procedure}{pair or \#f}}

  {[}R5RS+{]}
  alist must be an association list -- a list of pairs. These
  procedures find the first pair in alist whose car field is key, and
  returns that pair. If no pair in alist has key as its car, then
  \texttt{\#f} is returned. \texttt{assq} uses \texttt{eq?}  to
  compare key with the car fields of the pairs in alist, while
  \texttt{assv} uses \texttt{eqv?} and \texttt{assoc} uses
  \texttt{equal?}.

\begin{verbatim}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                            =>  (a 1)
(assq 'b e)                            =>  (b 2)
(assq 'd e)                            =>  #f
(assq (list 'a) '(((a)) ((b)) ((c))))  =>  #f
(assoc (list 'a) '(((a)) ((b)) ((c)))) =>  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    =>  *unspecified*
(assv 5 '((2 3) (5 7) (11 13)))    =>  (5 7)
\end{verbatim}

  \texttt{assoc} is extended from its R5RS definition to allow the
  client to pass in an optional equality procedure = used to compare
  keys.

  The comparison procedure is used to compare the elements
  e\textsubscript{i} of list to the key parameter in this way:

  \texttt{\ (=\ key\ (car\ ei))\ \ \ ;\ list\ is\ (E1\ ...\ En)}

  That is, the first argument is always key, and the second argument
  is one of the list elements. Thus one can reliably find the first
  entry of alist whose key is greater than five with \texttt{(assoc\
    5\ alist\ \textless{})}

  Note that fully general alist searching may be performed with the
  \texttt{find-tail} and \texttt{find} procedures, \emph{e.g.}

\begin{verbatim}
;; Look up the first association in alist with an even key:
(find (lambda (a) (even? (car a))) alist)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{alist-cons}{ key datum alist}{procedure}{alist}}

\begin{verbatim}
(lambda (key datum alist) (cons (cons key datum) alist))
\end{verbatim}

  Cons a new alist entry mapping key to  datum onto
  alist.
\end{entry}

\begin{entry}{%
  \Proto{alist-copy}{ alist}{procedure}{alist}} 

  Make a fresh
  copy of alist. This means copying each pair that forms an
  association as well as the spine of the list, \emph{i.e.}

\begin{verbatim}
(lambda (a) (map (lambda (elt) (cons (car elt) (cdr elt))) a))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{alist-delete}{ key alist =}{procedure}{alist}
  \Rproto{alist-delete}{ key alist}{procedure}{alist}
  \Proto{alist-delete!}{ key alist =}{procedure???}{alist}
  \Rproto{alist-delete!}{ key alist}{procedure???}{alist}}

  \texttt{alist-delete} deletes all associations from alist with the
  given key, using key-comparison procedure =, which defaults to
  \texttt{equal?}. The dynamic order in which the various applications
  of = are made is not specified.

  Return values may share common tails with the alist argument. The
  alist is not disordered -- elements that appear in the result alist
  occur in the same order as they occur in the argument alist.

  The comparison procedure is used to compare the element keys
  k\textsubscript{i} of alist's entries to the key parameter in this
  way: \texttt{(=\ key\ ki)}. Thus, one can reliably remove all
  entries of alist whose key is greater than five with
  \texttt{(alist-delete\ 5\ alist\ \textless{})}

  \texttt{alist-delete!} is the linear-update variant of
  \texttt{alist-delete}. It is allowed, but not required, to alter
  cons cells from the alist parameter to construct the result.
\end{entry}

\subsection{{Set operations on lists}}

These procedures implement operations on sets represented as lists of
elements. They all take an = argument used to compare elements of lists.
This equality procedure is required to be consistent with \texttt{eq?}.
That is, it must be the case that

\texttt{(eq?\ x\ y)} =\textgreater{} \texttt{(=\ x\ y)}.

Note that this implies, in turn, that two lists that are \texttt{eq?}
are also set-equal by any legal comparison procedure. This allows for
constant-time determination of set operations on \texttt{eq?} lists.

Be aware that these procedures typically run in time O(n * m) for n- and
m-element list arguments. Performance-critical applications operating
upon large sets will probably wish to use other data structures and
algorithms.

\begin{entry}{%
  \Proto{lset<=}{= list$_1$ \ldots}{procedure}{boolean}}

  Returns true iff every list\textsubscript{i} is a subset
  of list\textsubscript{i+1}, using = for the element-equality
  procedure.  List A is a subset of list B if every element in A is
  equal to some element of B. When performing an element comparison,
  the = procedure's first argument is an element of A; its second, an
  element of B.

\begin{verbatim}
(lset<= eq? '(a) '(a b a) '(a b c c)) => #t

(lset<= eq?) => #t             ; Trivial cases
(lset<= eq? '(a)) => #t
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lset=}{ = list$_1$ list$_2$ \ldots}{procedure}{boolean}}

Returns true iff every list$_i$ is set-equal to list$_{i+1}$, using =
for the element-equality procedure.  ``Set-equal'' simply means that
list$_i$ is a subset of list$_{i+1}$, and list$_{i+1}$ is a subset of
list$_i$. The = procedure's first argument is an element of list$_i$;
its second is an element of list$_{i+1}$.

\begin{verbatim}
(lset= eq? '(b e a) '(a e b) '(e e b a)) => #t

(lset= eq?) => #t               ; Trivial cases
(lset= eq? '(a)) => #t
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lset-adjoin}{ = list elt$_1$ \ldots}{procedure}{list}}

  Adds the elt$_i$ elements not already in the list parameter
  to the result list. The result shares a common tail with the list
  parameter. The new elements are added to the front of the list, but
  no guarantees are made about their order. The = parameter is an
  equality procedure used to determine if an elt$_i$ is already a
  member of list. Its first argument is an element of list; its second
  is one of the elt$_i$.

  The list parameter is always a suffix of the result -- even if the
  list parameter contains repeated elements, these are not reduced.

\begin{verbatim}
(lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u) => (u o i a b c d c e)
\end{verbatim}
\end{entry}


\begin{entry}{%
  \Proto{lset-union}{ = list$_1$ \ldots}{procedure}{list}}

  Returns the union of the lists, using = for the element-equality
  procedure.

  The union of lists A and B is constructed as follows:

\begin{itemize}
  \tightlist
\item If A is the empty list, the answer is B (or a copy of B).
\item Otherwise, the result is initialised to be list A (or a copy of
  A).
\item Proceed through the elements of list B in a left-to-right
  order. If b is such an element of B, compare every element r of the
  current result list to b: \texttt{(=\ r\ b)}. If all comparisons
  fail, b is consed onto the front of the result.
\end{itemize}

However, there is no guarantee that = will be applied to every pair of
arguments from A and B. In particular, if A is \texttt{eq}? to B, the
operation may immediately terminate.

In the n-ary case, the two-argument list-union operation is simply
folded across the argument lists.

\begin{verbatim}
(lset-union eq? '(a b c d e) '(a e i o u)) => 
    (u o i a b c d e)

;; Repeated elements in LIST1 are preserved.
(lset-union eq? '(a a c) '(x a x)) => (x a a c)

;; Trivial cases
(lset-union eq?) => ()
(lset-union eq? '(a b c)) => (a b c)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lset-intersection}{ = list$_1$ list$_2$
    \ldots}{procedure}{list}}

  Returns the intersection of the lists, using =
  for the element-equality procedure.

  The intersection of lists A and B is comprised of every element of A
  that is = to some element of B: \texttt{(=\ a\ b)}, for a in A, and
  b in B. Note this implies that an element which appears in B and
  multiple times in list A will also appear multiple times in the
  result.

  The order in which elements appear in the result is the same as they
  appear in list$_1$ -- that is, \texttt{lset-intersection}
  essentially filters list$_1$, without disarranging element
  order. The result may share a common tail with list$_1$.

  In the n-ary case, the two-argument list-intersection operation is
  simply folded across the argument lists. However, the dynamic order
  in which the applications of = are made is not specified. The
  procedure may check an element of list$_1$ for membership in every
  other list before proceeding to consider the next element of
  list$_1$, or it may completely intersect list$_1$ and list$_2$
  before proceeding to list$_3$, or it may go about its work in some
  third order.

\begin{verbatim}
(lset-intersection eq? '(a b c d e) '(a e i o u)) => (a e)

;; Repeated elements in LIST1 are preserved.
(lset-intersection eq? '(a x y a) '(x a x z)) => '(a x a)

(lset-intersection eq? '(a b c)) => (a b c)     ; Trivial case
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lset-difference}{ = list$_1$ list$_2$
    \ldots}{procedure}{list}}

  Returns the difference of the lists, using =
  for the element-equality procedure -- all the elements of list$_1$
  that are not = to any element from one of the other list$_i$
  parameters.

  The = procedure's first argument is always an element of list$_1$;
  its second is an element of one of the other list$_i$. Elements that
  are repeated multiple times in the list$_1$ parameter will occur
  multiple times in the result.  The order in which elements appear in
  the result is the same as they appear in list$_1$ -- that is,
  \texttt{lset-difference} essentially filters list$_1$, without
  disarranging element order. The result may share a common tail with
  list$_1$.  The dynamic order in which the applications of = are made
  is not specified. The procedure may check an element of list$_1$ for
  membership in every other list before proceeding to consider the
  next element of list$_1$, or it may completely compute the
  difference of list$_1$ and list$_2$ before proceeding to list$_3$,
  or it may go about its work in some third order.

\begin{verbatim}
(lset-difference eq? '(a b c d e) '(a e i o u)) => (b c d)

(lset-difference eq? '(a b c)) => (a b c) ; Trivial case
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lset-xor}{ = list$_1$ \ldots}{procedure}{list}}

  Returns the exclusive-or of the sets, using = for the
  element-equality procedure. If there are exactly two lists, this is
  all the elements that appear in exactly one of the two lists. The
  operation is associative, and thus extends to the n-ary case -- the
  elements that appear in an odd number of the lists. The result may
  share a common tail with any of the list$_i$ parameters.

  More precisely, for two lists A and B, A xor B is a list of

\begin{itemize}
  \tightlist
\item every element a of A such that there is no element b of B such
  that \texttt{(=\ a\ b)}, and
\item every element b of B such that there is no element a of A such
  that \texttt{(=\ b\ a)}.
\end{itemize}

However, an implementation is allowed to assume that = is symmetric --
that is, that

\texttt{(=\ a\ b)} =\textgreater{} \texttt{(=\ b\ a)}.

This means, for example, that if a comparison \texttt{(=\ a\ b)}
produces true for some a in A and b in B, both a and b may be removed
from inclusion in the result.

In the n-ary case, the binary-xor operation is simply folded across
the lists.

\begin{verbatim}
(lset-xor eq? '(a b c d e) '(a e i o u)) => (d c b i o u)

;; Trivial cases.
(lset-xor eq?) => ()
(lset-xor eq? '(a b c d e)) => (a b c d e)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lset-diff+intersection}{ = list$_1$ list$_2$
    \ldots}{procedure}{list list}}

  Returns two values -- the
  difference and the intersection of the lists.  Is equivalent to

\begin{verbatim}
(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))
\end{verbatim}

  but can be implemented more efficiently.

  The = procedure's first argument is an element of list$_1$; its
  second is an element of one of the other list$_i$.

  Either of the answer lists may share a common tail with
  list$_1$. This operation essentially partitions list$_1$.
\end{entry}

\begin{entry}{%
  \Proto{lset-union!}{ = list$_1$ \ldots}{procedure}{list}
  \Proto{lset-intersection!}{ = list$_1$ list$_2$ \ldots}{procedure}{list}
  \Proto{lset-difference!}{ = list$_1$ list$_2$ \ldots}{procedure}{list}
  \Proto{lset-xor!}{ = list$_1$ \ldots}{procedure}{list}
  \Proto{lset-diff+intersection!}{ = list$_1$ list$_2$
    \ldots}{procedure}{list list}}

  These are linear-update
  variants. They are allowed, but not required, to use the cons cells
  in their first list parameter to construct their
  answer. \texttt{lset-union!} is permitted to recycle cons cells from
  \emph{any} of its list arguments.
\end{entry}

\subsection{{Primitive side-effects}}

These two procedures are the primitive, R5RS
side-effect operations on pairs.


\begin{entry}{%
  \Proto{set-car!}{ pair object}{procedure}{unspecified}
  \Proto{set-cdr!}{ pair object}{procedure}{ unspecified}}

  {[}R5RS{]} These procedures store object in the car and cdr field of
  pair, respectively. The value returned is unspecified.

\begin{verbatim}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3) =>  *unspecified*
(set-car! (g) 3) =>  *error*
\end{verbatim}
\end{entry}


\subsection{{References \& links}}\label{references-links}

\TODO{What of this should survive in the final document?}

\begin{description}
\tightlist
\item[This document, in HTML: ]
\href{srfi-1.html}{http://srfi.schemers.org/srfi-1/srfi-1.html}
\item[Source code for the reference implementation: ]
\href{srfi-1-reference.scm}{http://srfi.schemers.org/srfi-1/srfi-1-reference.scm}
\item[Archive of SRFI-1 discussion-list email: ]
\href{mail-archive/maillist.html}{http://srfi.schemers.org/srfi-1/mail-archive/maillist.html}
\item[SRFI web site: ]
\url{http://srfi.schemers.org/}
\end{description}

\begin{description}
\tightlist
\item[\textbf{\href{}{{[}CommonLisp{]}}}]
\emph{Common Lisp: the Language}\\
Guy L. Steele Jr. (editor).\\
Digital Press, Maynard, Mass., second edition 1990.\\
Available at
\url{http://www.elwood.com/alu/table/references.htm\#cltl2}.

The Common Lisp ``HyperSpec,'' produced by Kent Pitman, is essentially
the ANSI spec for Common Lisp:
\url{http://www.harlequin.com/education/books/HyperSpec/}.
\item[\textbf{\href{}{{[}R5RS{]}}}]
Revised\textsuperscript{5} report on the algorithmic language Scheme.\\
R. Kelsey, W. Clinger, J. Rees (editors).\\
Higher-Order and Symbolic Computation, Vol. 11, No. 1, September,
1998.\\
and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998.\\
Available at \url{http://www.schemers.org/Documents/Standards/}.
\end{description}

