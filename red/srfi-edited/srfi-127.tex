\section{Lazy sequences}
\redno{13} What lazy sequence library should R7RS-large provide?

\begin{quote}
SRFI 127 is a variant of SRFI 1 for lazy sequences, which are either
proper lists or lists with a generator in the tail. They provide
medium-weight laziness.
\end{quote}

Lazy sequences (or lseqs, pronounced ``ell-seeks'') are a generalization
of lists. In particular, an lseq is either a proper list or a dotted
list whose last cdr is a
\href{http://srfi.schemers.org/srfi-121/srfi-121.html}{SRFI 121}
generator. A generator is a procedure that can be invoked with no
arguments in order to lazily supply additional elements of the lseq.
When a generator has no more elements to return, it returns an
end-of-file object. Consequently, lazy sequences cannot reliably contain
end-of-file objects.

This SRFI provides a set of procedures suitable for operating on lazy
sequences based on
\href{http://srfi.schemers.org/srfi-1/srfi-1.html}{SRFI 1}.

\setlibname{lseq}

\subsection{{Procedure Index}}\label{procedure-index}

Here is a short list of the procedures provided by this SRFI.

\begin{description}
\item[ Constructors ]
\begin{verbatim}
generator->lseq 
\end{verbatim}
\item[ Predicates ]
\begin{verbatim}
lseq?         lseq=?
\end{verbatim}
\item[ Selectors ]
\begin{verbatim}
lseq-car     lseq-cdr
lseq-first   lseq-rest lseq-ref
lseq-take    lseq-drop   
\end{verbatim}
\item[ The whole lazy sequence ]
\begin{verbatim}
lseq-realize lseq->generator
lseq-length
lseq-append  lseq-zip
\end{verbatim}
\item[ Mapping and filtering ]
\begin{verbatim}
lseq-map        lseq-for-each
lseq-filter     lseq-remove
\end{verbatim}
\item[ Searching ]
\begin{verbatim}
lseq-find         lseq-find-tail 
lseq-any          lseq-every
lseq-index
lseq-take-while   lseq-drop-while
lseq-member       lseq-memq     lseq-memv
\end{verbatim}
\end{description}

\subsection{{Specification}}\label{specification}

The templates given below obey the following conventions for procedure
formals:

\begin{tabular}{ll}
lseq & A lazy sequence\\
x, y, a, b & Any value\\
object, value & Any value\\
n, i & A natural number (an integer >= 0)\\
proc & A procedure\\
pred & A procedure whose return value is treated as a
boolean\\
generator & A procedure with no arguments that returns a sequence of
values\\
= & A boolean procedure taking two arguments\\
\end{tabular}

To interpret the examples, pretend that they are executed on a Scheme
that prints lazy sequences with the syntax of lists, truncating them
when they get too long.

\subsection{{Constructors}}\label{constructors}

Every list constructor procedure is also an lseq constructor procedure.
The procedure \texttt{generator->lseq} constructs an lseq
based on the values of a generator. In order to prepend a value to an
lseq, simply use \texttt{cons}; to prepend more than one value, use SRFI
1's \texttt{cons*}.

\begin{entry}{%
  \Proto{generator->lseq}{ generator}{procedure}{lseq}}

  Returns an lseq whose elements are the values generated by
  generator.  The exact behavior is as follows:

\begin{itemize}
  \tightlist
\item Generator is invoked with no arguments to produce an object obj.
\item If obj is an end-of-file object, the empty list is returned.
\item Otherwise, a newly allocated pair whose car is obj and whose cdr
  is generator is returned.
\end{itemize}

\begin{verbatim}
(generator->lseq (make-iota-generator +inf.0 1)) => (1 2 3 ...)
\end{verbatim}
\end{entry}
\subsection{{Predicates}}\label{predicates}

\begin{entry}{%
  \Proto{lseq?}{ x}{procedure}{boolean}}

  Returns \texttt{\#t} if x is an
  lseq. This procedure may also return \texttt{\#t} if x is an
  improper list whose last cdr is a procedure that requires arguments,
  since there is no portable way to examine a procedure to determine
  how many arguments it requires. Otherwise it returns \texttt{\#f}.
\end{entry}

\begin{entry}{%
  \Proto{lseq=?}{ elt=? lseq$_1$ lseq$_2$}{procedure}{boolean}}

  Determines
  lseq equality, given an element-equality procedure. Two lseqs are
  equal if they are of the same length, and their corresponding
  elements are equal, as determined by elt=?. When elt=? is called,
  its first argument is always from lseq$_1$ and its second argument
  is from lseq$_2$.

  The dynamic order in which the elt=? procedure is applied to pairs
  of elements is not specified.

  The elt=? procedure must be consistent with \texttt{eq?}. This
  implies that two lseqs which are \texttt{eq?} are always
  \texttt{lseq=?}, as well; implementations may exploit this fact to
  ``short-cut'' the element-by-element equality tests.
\end{entry}

\subsection{{Selectors}}\label{selectors}

\begin{entry}{%
  \Proto{lseq-car}{ lseq}{procedure}{object}
  \Proto{lseq-first}{ lseq}{procedure}{object}}

  These procedures are synonymous. They return the first element of
  lseq.  They are included for completeness, as they are the same as
  \texttt{car}. It is an error to apply them to an empty lseq.
\end{entry}

\begin{entry}{%
  \Proto{lseq-cdr}{ lseq}{procedure}{lseq}
  \Proto{lseq-rest}{ lseq}{procedure}{lseq}}

  These procedures are synonymous. They return an lseq with the
  contents of lseq except for the first element. The exact behavior is
  as follows:

  If lseq is a pair whose cdr is a procedure, then the procedure is
  invoked with no arguments to produce an object obj.

\begin{itemize}
  \tightlist
\item If obj is an end-of-file object, then the cdr of lseq is set to
  the empty list, which is returned.
\item If obj is any other object, then a new pair is allocated whose
  car is \emph{obj} and whose cdr is the cdr of lseq (i.e. the
  procedure). The cdr of lseq is set to the newly allocated pair,
  which is returned.
\end{itemize}

If lseq is a pair whose cdr is not a procedure, then the cdr is
returned.

If lseq is not a pair, it is an error.
\end{entry}

\begin{entry}{%
  \Proto{lseq-ref}{ lseq i}{procedure}{value}}

  Returns the ith element of lseq. (This is the same as
  \texttt{(lseq-first\ (lseq-drop\ lseq\ i))}.) It is an error if i >=
  n, where n is the length of lseq.

\begin{verbatim}
    
(lseq-ref '(a b c d) 2) => c
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-take}{ lseq i}{procedure}{lseq}
  \Proto{lseq-drop}{ lseq i}{procedure}{lseq}}

  \texttt{lseq-take} lazily returns the first i elements of lseq.
  \texttt{lseq-drop} returns all but the first i elements of lseq.

\begin{verbatim}
(lseq-take '(a b c d e)  2) => (a b)
(lseq-drop '(a b c d e)  2) => (c d e)
\end{verbatim}

  \texttt{lseq-drop} is exactly equivalent to performing i
  \texttt{lseq-rest} operations on lseq.
\end{entry}

\subsection{{The whole lazy sequence}}\label{the-whole-lazy-sequence}

\begin{entry}{%
  \Proto{lseq-realize}{ lseq}{procedure}{list}}

  Repeatedly applies
  \texttt{lseq-cdr} to lseq until its generator (if there is one) has
  been exhausted, and returns lseq, which is now guaranteed to be a
  proper list. This procedure can be called on an arbitrary lseq
  before passing it to a procedure which only accepts lists. However,
  if the generator never returns an end-of-file object,
  \texttt{lseq-realize} will never return.
\end{entry}

\begin{entry}{%
  \Proto{lseq->generator}{ lseq}{procedure}{generator}}

  Returns a generator which when invoked will return all the elements
  of lseq, including any that have not yet been realized.
\end{entry}

\begin{entry}{%
  \Proto{lseq-length}{ olseq}{procedure}{integer}}

  Returns the length of its argument, which is the non-negative
  integer n such that \texttt{lseq-rest} applied n times to the lseq
  produces an empty lseq. lseq must be finite, or this procedure will
  not return.
\end{entry}

\begin{entry}{%
  \Proto{lseq-append}{ lseq \ldots}{procedure}{lseq}}

  Returns an lseq that
  lazily contains all the elements of all the lseqs in order.
\end{entry}



\begin{entry}{%
  \Proto{lseq-zip}{ lseq$_1$ lseq$_2$ \ldots}{procedure}{lseq}}

  If \texttt{lseq-zip} is passed n lseqs, it lazily returns an lseq
  each element of which is an n-element list comprised of the
  corresponding elements from the lseqs. If any of the lseqs are
  finite in length, the result is as long as the shortest lseq.

\begin{verbatim}
(lseq-zip '(one two three) 
     (generator->lseq (make-iota-generator +inf.0 1 1))
     (generator->lseq (make-repeating-generator) '(odd even))))
    => ((one 1 odd) (two 2 even) (three 3 odd))

(lseq-zip '(1 2 3)) => ((1) (2) (3))
\end{verbatim}
\end{entry}

\subsection{{Mapping and filtering}}\label{mapping-and-filtering}

\begin{entry}{%
  \Proto{lseq-map}{ proc lseq$_1$ lseq$_2$ \ldots}{procedure}{lseq}}

  The \texttt{lseq-map} procedure lazily applies proc element-wise to
  the corresponding elements of the lseqs, where proc is a procedure
  taking as many arguments as there are lseqs and returning a single
  value, and returns an lseq of the results in order. The dynamic
  order in which proc is applied to the elements of the lseqs is
  unspecified.

\begin{verbatim}
(lseq-map
  (lambda (x) (lseq-car (lseq-cdr x)))
  '((a b) (d e) (g h))) =>  (b e h)

(lseq-map (lambda (n) (expt n n))
     (make-iota-generator +inf.0 1 1)
    =>  (1 4 27 256 3125 ...)

(lseq-map + '(1 2 3) '(4 5 6)) =>  (5 7 9)

(let ((count 0))
  (lseq-map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b))) =>  (1 2) or (2 1)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-for-each}{ proc lseq$_1$ lseq$_2$ \ldots}{procedure}{unspecified}}

  The arguments to \texttt{lseq-for-each} are like the arguments to
  \texttt{lseq-map}, but \texttt{lseq-for-each} calls proc for its
  side effects rather than for its values. Unlike \texttt{lseq-map},
  \texttt{lseq-for-each} is guaranteed to call proc on the elements of
  the lseqs in order from the first element(s) to the last, and the
  value returned by \texttt{lseq-for-each} is unspecified.

  If none of the lseqs are finite, \texttt{lseq-for-each} never
  returns.

\begin{verbatim}
(let ((v (make-vector 5)))
  (lseq-for-each (let ((count 0))
                   (lambda (i)
                     (vector-set! v count (* i i))
                     (set! count (+ count 1))))
                 '(0 1 2 3 4))
  v)
  =>  (#0 1 2 3 4)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-filter}{ pred lseq}{procedure}{lseq}
  \Proto{lseq-remove}{ pred lseq}{procedure}{lseq}}

  The procedure \texttt{lseq-filter} lazily returns an lseq that
  contains only the elements of lseq that satisfy pred.

  The procedure \texttt{lseq-remove} is the same as
  \texttt{lseq-filter}, except that it returns elements that do not
  satisfy pred. These procedures are guaranteed to call pred on the
  elements of the lseqs in sequence order.

\begin{verbatim}
(lseq-filter odd? (generator->lseq (make-range-generator 1 5)))
  =>  (1 3)
(lseq-remove odd? (generator->lseq (make-range-generator 1 5)))
  =>  (2 4)
\end{verbatim}
\end{entry}

\subsection{{Searching}}\label{searching}

The following procedures all search lseqs for the leftmost element
satisfying some criterion.

\begin{entry}{%
  \Proto{lseq-find}{ pred lseq}{procedure}{value}}

  Return the first element of lseq that satisfies predicate pred, or
  \texttt{\#f} if no element does. It cannot reliably be applied to
  lseqs that include \texttt{\#f} as an element; use
  \texttt{lseq-find-tail} instead. The predicate is guaranteed to be
  evaluated on the elements of lseq in sequence order, and only as
  often as necessary.

\begin{verbatim}
(lseq-find even? '(3 1 4 1 5 9 2 6)) => 4
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-find-tail}{ pred lseq}{procedure}{lseq \textrm{or} \texttt{\#f}}}

  Returns the longest tail of lseq whose first element satisfies pred,
  or \texttt{\#f} if no element does. The predicate is guaranteed to
  be evaluated on the elements of lseq in sequence order, and only as
  often as necessary.

  \texttt{lseq-find-tail} can be viewed as a general-predicate variant
  of the \texttt{lseq-member} function.

  Examples:

\begin{verbatim}
(lseq-find-tail even? '(3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
(lseq-find-tail even? '(3 1 37 -5)) => #f

;; equivalent to (lseq-member elt lseq)
(lseq-find-tail (lambda (elt) (equal? x elt)) lseq)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-take-while}{ pred lseq}{procedure}{lseq}}

  Lazily returns the longest initial prefix of lseq whose elements all
  satisfy the predicate pred.

\begin{verbatim}
(lseq-take-while even? '(2 18 3 10 22 9)) => (2 18)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-drop-while}{ pred lseq}{procedure}{lseq}}

  Drops the longest initial prefix of lseq whose elements all satisfy
  the predicate pred, and returns the rest of the lseq.

\begin{verbatim}
(lseq-drop-while even? '(2 18 3 10 22 9)) => (3 10 22 9)
\end{verbatim}

  Note that \texttt{lseq-drop-while} is essentially
  \texttt{lseq-find-tail} where the sense of the predicate is
  inverted: \texttt{lseq-find-tail} searches until it finds an element
  satisfying the predicate; \texttt{lseq-drop-while} searches until it
  finds an element that \emph{doesn't} satisfy the predicate.
\end{entry}

\begin{entry}{%
  \Proto{lseq-any}{ pred lseq$_1$ lseq$_2$ \ldots}{procedure}{value}}

  Applies pred to successive elements of the lseqs, returning true if
  pred returns true on any application. If an application returns a
  true value, \texttt{lseq-any} immediately returns that
  value. Otherwise, it iterates until a true value is produced or one
  of the lseqs runs out of values; in the latter case,
  \texttt{lseq-any} returns \texttt{\#f}. It is an error if
  \emph{pred} does not accept the same number of arguments as there
  are \emph{lseqs} and return a boolean result.

  Note the difference between \texttt{lseq-find} and
  \texttt{lseq-any}---\texttt{lseq-find} returns the element that
  satisfied the 
  predicate; \texttt{lseq-any} returns the true value that the
  predicate produced.

  Like \texttt{lseq-every}, \texttt{lseq-any}'s name does not end with
  a question mark---this is to indicate that it does not return a
  simple boolean (\texttt{\#t} or \texttt{\#f}), but a general value.

\begin{verbatim}
(lseq-any integer? '(a 3 b 2.7))   => #t
(lseq-any integer? '(a 3.1 b 2.7)) => #f
(lseq-any < '(3 1 4 1 5)
       '(2 7 1 8 2)) => #t
\end{verbatim}

\begin{verbatim}
(define (factorial n)
  (cond
    ((< n 0) #f)
    ((= n 0) 1)
    (else (* n (factorial (- n 1))))))
(lseq-any factorial '(-1 -2 3 4))
        => 6
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-every}{ pred lseq$_1$ lseq$_2$ \ldots}{procedure}{value}}

  Applies pred to successive elements of the lseqs, returning true if
  the predicate returns true on every application. If an application
  returns a false value, \texttt{lseq-every} immediately returns that
  value.  Otherwise, it iterates until a false value is produced or
  one of the lseqs runs out of values; in the latter case,
  \texttt{lseq-every} returns the last value returned by pred, or
  \texttt{\#t} if pred was never invoked. It is an error if
  \emph{pred} does not accept the same number of arguments as there
  are \emph{lseqs} and return a boolean result.

  Like \texttt{lseq-any}, \texttt{lseq-every}'s name does not end with
  a question mark---this is to indicate that it does not return a
  simple boolean (\texttt{\#t} or \texttt{\#f}), but a general value.

\begin{verbatim}
(lseq-every factorial '(1 2 3 4))
        => 24
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{lseq-index}{ pred lseq$_1$ lseq$_2$ \ldots}{procedure}{integer \textrm{or} \texttt{\#f}}}

  Return the index of the leftmost element that satisfies pred.

  Applies pred to successive elements of the lseqs, returning an index
  usable with \texttt{lseq-ref} if the predicate returns
  true. Otherwise, it iterates until one of the lseqs runs out of
  values, in which case \texttt{\#f} is returned.

  It is an error if \emph{pred} does not accept the same number of
  arguments as there are \emph{lseqs} and return a boolean result.

  The iteration stops when one of the lseqs runs out of values; in
  this case, \texttt{lseq-index} returns \texttt{\#f}.

\begin{verbatim}
(lseq-index even? '(3 1 4 1 5 9)) => 2
(lseq-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => 1
(lseq-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => #f
\end{verbatim}
\end{entry}


\begin{entry}{%
  \Proto{lseq-member}{ x lseq pred}{procedure}{lseq}
  \Proto{lseq-member}{ x lseq}{procedure}{lseq}
  \Proto{lseq-memq}{ x lseq}{procedure}{lseq}
  \Proto{lseq-memv}{ x lseq}{procedure}{lseq}}

  These procedures return the longest tail of lseq whose first element
  is x, where the tails of lseq are the non-empty lseqs returned by
  \texttt{(lseq-drop\ lseq\ i)} for i less than the length of lseq. If
  x does not occur in lseq, then \texttt{\#f} is returned.
  \texttt{lseq-memq} uses \texttt{eq?} to compare x with the elements
  of lseq, while \texttt{lseq-memv} uses \texttt{eqv?}, and
  \texttt{lseq-member} uses pred, which defaults to \texttt{equal?}.

\begin{verbatim}
    (lseq-memq 'a '(a b c))           =>  (a b c)
    (lseq-memq 'b '(a b c))           =>  (b c)
    (lseq-memq 'a '(b c d))           =>  #f
    (lseq-memq (list 'a) '(b (a) c)) =>  #f
    (lseq-member (list 'a)
            '(b (a) c))           =>  ((a) c)
    (lseq-memq 101 '(100 101 102))    =>  *unspecified*
    (lseq-memv 101 '(100 101 102))    =>  (101 102)
\end{verbatim}

  The equality procedure is used to compare the elements
  e\textsubscript{i} of lseq to the key x in this way: the first
  argument is always x, and the second argument is one of the lseq
  elements. Thus one can reliably find the first element of lseq that
  is greater than five with \texttt{(lseq-member\ 5\ lseq\
    \textless{})}

  Note that fully general lseq searching may be performed with the
  \texttt{lseq-find-tail} procedure, \emph{e.g.}

\begin{verbatim}
(lseq-find-tail even? lseq) ; Find the first elt with an even key.
\end{verbatim}
\end{entry}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}
