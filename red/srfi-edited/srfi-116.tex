\section{Immutable pairs and lists}
\redno{8} What immutable pair/list library should R7RS-large provide?

\begin{quote}
SRFI 116 is a variant of SRFI 1 for immutable pairs, which are a
separate data type from ordinary Scheme pairs. Only a few functional
update procedures are provided. Procedure names are prefixed with ``i''.
\end{quote}

\TODO{Much of this SRFI repeats text from SRFI-1. Could some of it be
  reduced?}

\textbf{Post-finalization note:} One sentence has been added to the
section ``The procedures'' below, and several errors in the examples
have been silently corrected. These do not affect the conformance
conditions for this SRFI.


Scheme currently does not provide immutable pairs corresponding to its
existing mutable pairs, although most uses of pairs do not exploit their
mutability. The \href{http://www.racket-lang.org}{Racket} system takes
the radical approach of making Scheme's pairs immutable, and providing a
minimal library of mutable pairs with procedures named
\texttt{mpair?,\ mcons,\ mcar,\ mcdr,\ set-mcar!,\ set-mcdr!}. This SRFI
takes the opposite approach of leaving Scheme's pairs unchanged and
providing a full set of routines for creating and dealing with immutable
pairs. The sample implementation is portable (to systems with SRFI 9)
and efficient.

\setlibname{ilist}

\subsection{{Procedure Index}}\label{procedure-index}

Here is a short list of the procedures provided by this SRFI.

\begin{description}
\item[ Constructors ]
\begin{verbatim}
ipair ilist
xipair ipair* make-ilist ilist-tabulate  
ilist-copy iiota
\end{verbatim}
\item[ Predicates ]
\begin{verbatim}
ipair?
proper-ilist?/ilist? dotted-ilist? 
not-ipair? null-ilist?
ilist=
\end{verbatim}
\item[ Selectors ]
\begin{verbatim}
icar icdr ... icddadr icddddr ilist-ref
ifirst isecond ithird ifourth ififth 
isixth iseventh ieighth ininth itenth
icar+icdr
itake       idrop/ilist-tail
itake-right idrop-right
isplit-at   
ilast last-ipair
\end{verbatim}
\item[ Miscellaneous: length, append, concatenate, reverse, zip \& count
]
\begin{verbatim}
ilength 
iappend  iconcatenate  ireverse  iappend-reverse
izip iunzip1 iunzip2 iunzip3 iunzip4 iunzip5
icount
\end{verbatim}
\item[ Fold, unfold \& map ]
\begin{verbatim}
imap        ifor-each
ifold       iunfold        ipair-fold       ireduce 
ifold-right iunfold-right  ipair-fold-right ireduce-right 
iappend-map ipair-for-each ifilter-map      imap-in-order
\end{verbatim}
\item[ Filtering \& partitioning ]
\begin{verbatim}
ifilter  ipartition  iremove
\end{verbatim}
\item[ Searching ]
\begin{verbatim}
imember imemq imemv
ifind         ifind-tail 
iany ievery
ilist-index
itake-while   idrop-while
ispan ibreak
\end{verbatim}
\item[ Deleting ]
\begin{verbatim}
idelete       idelete-duplicates 
\end{verbatim}
\item[ Immutable association lists ]
\begin{verbatim}
iassoc iassq iassv
ialist-cons  ialist-delete
\end{verbatim}
\item[ Replacement ]
\begin{verbatim}
replace-icar replace-icdr
\end{verbatim}
\item[ Conversion ]
\begin{verbatim}
pair->ipair  ipair->pair
list->ilist  ilist->list
tree->itree  itree->tree
gtree->itree gtree->tree
\end{verbatim}
\item[ Procedure application ]
\begin{verbatim}
iapply
\end{verbatim}
\item[ Comparators ]
\begin{verbatim}
ipair-comparator        ilist-comparator
make-ilist-comparator   make-improper-ilist-comparator
make-icar-comparator    make-icdr-comparator
\end{verbatim}
\end{description}


\subsection{{Quotation}}\label{quotation}

\TODO{Sort out where this goes. Some of this definitely belongs in the
  Rationale, while some of the rest belongs here. Rather than
  “recommending”, something slightly stronger is needed?}

The various Scheme standards permit, but do not require, Scheme
implementations to treat quoted pairs and lists as immutable. Thus
whereas the expression
\texttt{(let\ ((foo\ (list\ 1\ 2\ 3)))\ (set-car!\ foo\ 10)\ foo)}
evaluates to \texttt{(10\ 2\ 3)}, the value of
\texttt{(let\ ((foo\ \textquotesingle{}(1\ 2\ 3)))\ (set-car!\ foo\ 10)\ foo)}
is not portable, and is in fact an error.

This SRFI recommends that implementations that provide both this SRFI
and immutable quotations should cause quotations to return the same
immutable pairs that this SRFI describes. This means that the standard
Scheme pair and list operations, as well as libraries like SRFI 1 which
are built on them, should accept both mutable and immutable pairs: thus
\texttt{(car\ (ilist\ 1\ 2))} should evaluate to \texttt{1}.

This SRFI further recommends that \texttt{read} should return mutable
pairs and lists when reading list structure. No recommendation is made
about the behavior of \texttt{write}, \texttt{display}, and similar
output procedures on immutable lists.

To make life easier for Scheme programmers, given that many
implementations do not provide immutable quotation, the syntax keyword
\texttt{iq} is provided as part of this SRFI. It is analogous to
\texttt{quote}, taking an arbitrary number of literals and constructing
an ilist from them, with any pairs in the literals converted to ipairs.
It is useful for providing constant ipair-based objects. Note that pairs
within literal vectors or other implementation-dependent literals will
not be converted. Unfortunately, there is no ilist analogue of
\texttt{\textquotesingle{}}, so we save keystrokes by using \texttt{iq}
rather than \texttt{iquote} and omitting the top-level parentheses.

\subsection{Notation}

The templates given below obey the following conventions for procedure
formals:

\begin{tabular}{ll}
ilist & A proper (\texttt{()}-terminated) ilist\tabularnewline
dilist & A proper or dotted ilist\tabularnewline
ipair & An immutable pair\tabularnewline
x, y, d, a & Any value\tabularnewline
object, value & Any value\tabularnewline
n, i & A natural number (an integer \textgreater{}= 0)\tabularnewline
proc & A procedure\tabularnewline
pred & A procedure whose return value is treated as a
boolean\tabularnewline
= & A boolean procedure taking two arguments\tabularnewline
\end{tabular}

To interpret the examples, pretend that they are executed on a Scheme
that prints immutable pairs and lists with the syntax of mutable ones.

It is an error to pass a dotted ilist to a procedure not defined to
accept such an argument.

\textbf{Added after finalization:} Implementers should extend the Scheme
predicate \texttt{equal?} to descend into immutable pairs in the same
way that it descends into mutable pairs.

\subsubsection{Constructors}

\begin{entry}{%
  \Proto{ipair}{ a d}{procedure}{ipair}}

  The
    primitive constructor. Returns a newly allocated ipair whose icar
    is a and whose icdr is d. The ipair is guaranteed to be different
    (in the sense of \texttt{eqv?}) from every existing object.

\begin{verbatim}
(ipair 'a '())        => (a)
(ipair (iq a) (iq b c d)) => ((a) b c d)
(ipair "a" (iq b c))    => ("a" b c)
(ipair 'a 3)          => (a . 3)
(ipair (iq a b) 'c)     => ((a b ) . c)
\end{verbatim}
  \end{entry}
  
\begin{entry}{%
  \Proto{ilist}{ object \ldots}{procedure}{ilist}}

Returns a newly allocated ilist of its arguments.

\begin{verbatim}
(ilist 'a (+ 3 4) 'c) =>  (a 7 c)
(ilist)               =>  ()
\end{verbatim}
  \end{entry}

\begin{entry}{%
  \Proto{xipair}{ d a}{procedure}{ipair}}

\begin{verbatim}
(lambda (d a) (ipair a d))
\end{verbatim}

    Of utility only as a value to be conveniently passed to
    higher-order procedures.

\begin{verbatim}
(xipair (iq b c) 'a) => (a b c)
\end{verbatim}

    The name stands for ``eXchanged Immutable PAIR.'' 
\end{entry}

\begin{entry}{%
  \Proto{ipair*}{ elt$_1$ elt$_2$ \ldots}{procedure}{object}}

Like \texttt{ilist}, but the last argument provides the
    tail of the constructed ilist, returning

    \texttt{\ (ipair\ elt1\ (ipair\ elt2\ (ipair\ ...\ eltn)))\ \ \ \
      \ }

\begin{verbatim}
(ipair* 1 2 3 4) => (1 2 3 . 4)
(ipair* 1) => 1
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{make-ilist}{ n fill}{procedure}{ilist}
  \Rproto{make-ilist}{ n}{procedure}{ilist}}

  Returns an n-element ilist, whose elements are all the value
  fill. If the fill argument is not given, the elements of the ilist
  may be arbitrary values.

\begin{verbatim}
(make-ilist 4 'c) => (c c c c)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ilist-tabulate}{ n init-proc}{procedure}{ilist}}

  Returns an n-element ilist. Element i of the ilist, where 0
  \textless{}= i \textless{} n, is produced by \texttt{(init-proc\
    i)}. No guarantee is made about the dynamic order in which
  init-proc is applied to these indices.

\begin{verbatim}
(ilist-tabulate 4 values) => (0 1 2 3)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ilist-copy}{ dilist}{procedure}{dilist}}

  Copies the
  spine of the argument, including the ilist tail.
\end{entry}

\begin{entry}{%
  \Proto{iiota}{ count start step}{procedure}{ilist}
  \Rproto{iiota}{ count start}{procedure}{ilist}
  \Rproto{iiota}{ count}{procedure}{ilist}}

Returns an ilist containing the elements

\begin{verbatim}
(start start+step ... start+(count-1)*step)
\end{verbatim}

  The start and step parameters default to 0 and 1, respectively. This
  procedure takes its name from the APL primitive.

\begin{verbatim}
(iiota 5) => (0 1 2 3 4)
(iiota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)
\end{verbatim}
\end{entry}

\subsubsection{{Predicates}}\label{predicates}

\begin{entry}{%
  \Proto{proper-ilist?}{ x}{procedure}{boolean}
  \Proto{ilist?}{ x}{procedure}{boolean}}

These identifiers are
  bound either to the same procedure, or to procedures of equivalent
  behavior. In either case, true is returned iff x is a proper
  ilist---a \texttt{()}-terminated ilist. 

  More carefully: The empty list is a proper ilist. An ipair whose
  icdr is a proper ilist is also a proper ilist. Everything else is a
  dotted ilist. This includes non-ipair, non-() values (\emph{e.g.}
  symbols, numbers, mutable pairs), which are considered to be dotted
  ilists of length 0.
\end{entry}

\begin{entry}{%
  \Proto{dotted-ilist?}{ x}{procedure}{boolean}}

  True if x is
  a finite, non-nil-terminated ilist. That is, there exists an n
  \textgreater{}= 0 such that icdr\textsuperscript{n}(x) is neither an
  ipair nor (). This includes non-ipair, non-() values (\emph{e.g.}
  symbols, numbers), which are considered to be dotted ilists of
  length 0.

\begin{verbatim}
(dotted-ilist? x) = (not (proper-ilist? x))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ipair?}{ object}{procedure}{boolean}}

  Returns \#t if
  object is an ipair; otherwise, \schfalse{}.

\begin{verbatim}
(ipair? (ipair 'a 'b)) =>  #t
(ipair? (iq a b c)) =>  #t
(ipair? (cons 1 2)) =>  #f
(ipair? '())        =>  #f
(ipair? '#(a b))    =>  #f
(ipair? 7)          =>  #f
(ipair? 'a)         =>  #f
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{null-ilist?}{ ilist}{procedure}{boolean}}

  Ilist is a
  proper ilist. This procedure returns true if the argument is the
  empty list (), and \schfalse{} otherwise. It is an error to pass this
  procedure a value which is not a proper ilist. This procedure is
  recommended as the termination condition for ilist-processing
  procedures that are not defined on dotted ilists.
\end{entry}

\begin{entry}{%
  \Proto{not-ipair?}{ x}{procedure}{boolean}}

\begin{verbatim}
(lambda (x) (not (ipair? x)))
\end{verbatim}

  Provided as a procedure as it can be useful as the termination
  condition for ilist-processing procedures that wish to handle all
  ilists, both proper and dotted.
\end{entry}

\begin{entry}{%
  \Proto elt={ilist$_1$ \ldots}{procedure}{n}}

  Determines ilist equality, given an
  element-equality procedure. Proper ilist A equals proper ilist B if
  they are of the same length, and their corresponding elements are
  equal, as determined by elt=. If the element-comparison procedure's
  first argument is from ilist$_i$, then its second
  argument is from ilist\textsubscript{i+1}, \emph{i.e.} it is always
  called as \texttt{(elt=\ a\ b)} for a an element of ilist A, and b
  an element of ilist B.

  In the n-ary case, every ilist$_i$ is compared to
  ilist\textsubscript{i+1} (as opposed, for example, to comparing
  ilist\textsubscript{1} to ilist$_i$, for
  i\textgreater{}1).  If there are no ilist arguments at all,
  \texttt{ilist=} simply returns true.

  It is an error to apply \texttt{ilist=} to anything except proper
  ilists. It cannot reasonably be extended to dotted ilists, as it
  provides no way to specify an equality procedure for comparing the
  ilist terminators.

  Note that the dynamic order in which the elt= procedure is applied
  to pairs of elements is not specified. For example, if
  \texttt{ilist=} is applied to three ilists, A, B, and C, it may
  first completely compare A to B, then compare B to C, or it may
  compare the first elements of A and B, then the first elements of B
  and C, then the second elements of A and B, and so forth.

  The equality procedure must be consistent with \texttt{eq?}. That
  is, it must be the case that

  \texttt{(eq?\ x\ y)} =\textgreater{} \texttt{(elt=\ x\ y)}.

  Note that this implies that two ilists which are \texttt{eq?} are
  always \texttt{ilist=}, as well; implementations may exploit this
  fact to ``short-cut'' the element-by-element comparisons.

\begin{verbatim}
(ilist= eq?) => #t       ; Trivial cases
(ilist= eq? (iq a)) => #t
\end{verbatim}
\end{entry}

\subsubsection{{Selectors}}\label{selectors}


\begin{entry}{%
  \Proto{icar}{ ipair}{procedure}{value}
  \Proto{icdr}{ ipair}{procedure}{value}}

  These procedures return
  the contents of the icar and icdr field of their argument,
  respectively. Note that it is an error to apply them to the empty
  ilist.

\begin{verbatim}
(icar (iq a b c))       =>  a        (icdr (iq a b c))     =>  (b c)  
(icar (iq (a) b c d))   =>  (a)       (icdr (iq (a) b c d)) =>  (b c d)
(icar (ipair 1 2))      =>  1         (icdr (ipair 1 2))    =>  2      
(icar '())              =>  *error*  (icdr '())            =>  *error*
\end{verbatim}
\end{entry}
   
\begin{entry}{%
  \Proto{icaar}{ ipair}{procedure}{value}
  \Proto{icadr}{ ipair}{procedure}{value}
  \texttt{:}\\
  \Proto{icdddar}{ ipair}{procedure}{value}
  \Proto{icddddr}{ ipair}{procedure}{value}}

  These procedures are
  compositions of \texttt{icar} and \texttt{icdr}, where for example
  \texttt{icaddr} could be defined by

\begin{verbatim}
    
(define icaddr (lambda (x) (icar (icdr (icdr x))))).
\end{verbatim}

  Arbitrary compositions, up to four deep, are provided. There are
  twenty-eight of these procedures in all.
\end{entry}

\begin{entry}{%
  \Proto{ilist-ref}{ ilist i}{procedure}{value}}

  Returns the
  i\textsuperscript{th} element of ilist. (This is the same as the
  icar of \texttt{(idrop\ ilist\ i)}.) It is an error if i
  \textgreater{}= n, where n is the length of ilist.

\begin{verbatim}   
(ilist-ref (iq a b c d) 2) => c
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ifirst}{ipair}{procedure}{object}
  \Proto{isecond}{ipair}{procedure}{object}
  \Proto{ithird}{ipair}{procedure}{object}
  \Proto{ifourth}{ipair}{procedure}{object}
  \Proto{ififth}{ipair}{procedure}{object}
  \Proto{isixth}{ipair}{procedure}{object}
  \Proto{iseventh}{ipair}{procedure}{object}
  \Proto{ieighth}{ipair}{procedure}{object}
  \Proto{ininth}{ipair}{procedure}{object}
  \Proto{itenth}{ipair}{procedure}{object}}

Synonyms for
  \texttt{car}, \texttt{cadr}, \texttt{caddr}, \ldots{}

\begin{verbatim}
(ithird '(a b c d e)) => c
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{icar+icdr}{ ipair}{procedure}{x y}}

  The fundamental ipair deconstructor:

\begin{verbatim}
(lambda (p) (values (icar p) (icdr p)))
\end{verbatim}

  This can, of course, be implemented more efficiently by a compiler.
\end{entry}

\begin{entry}{%
  \Proto{itake}{ x i}{procedure}{ilist}
  \Proto{idrop}{ x i}{procedure}{object}
  \Proto{ilist-tail}{ x i}{procedure}{object}}

  \texttt{itake} returns the first i elements of ilist x.\\
  \texttt{idrop} returns all but the first i elements of ilist x.\\
  \texttt{ilist-tail} is either the same procedure as \texttt{idrop}
  or else a procedure with the same behavior.

\begin{verbatim}
(itake (iq a b c d e)  2) => (a b)
(idrop (iq a b c d e)  2) => (c d e)
\end{verbatim}

  x may be any value---a proper or dotted ilist:

\begin{verbatim}
(itake (ipair 1 (ipair 2 (ipair 3 'd)))    => (1 2)
(idrop (ipair 1 (ipair 2 (ipair 3 'd))) 2) => (3 . d)
(itake (ipair 1 (ipair 2 (ipair 3 'd))) 3) => (1 2 3)
(idrop (ipair 1 (ipair 2 (ipair 3 'd))) 3) => d
\end{verbatim}

  For a legal i, \texttt{itake} and \texttt{idrop} partition the ilist
  in a manner which can be inverted with \texttt{iappend}:

\begin{verbatim}
(iappend (itake x i) (idrop x i)) = x
\end{verbatim}

  \texttt{idrop} is exactly equivalent to performing i icdr operations
  on x; the returned value shares a common tail with x.
\end{entry}

\begin{entry}{%
  \Proto{itake-right}{ dilist i}{procedure}{object}
  \Proto{idrop-right}{ dilist i}{procedure}{ilist}}

  \texttt{itake-right} returns the last i elements of dilist.\\
  \texttt{idrop-right} returns all but the last i elements of dilist.

\begin{verbatim}
(itake-right (iq a b c d e) 2) => (d e)
(idrop-right (iq a b c d e) 2) => (a b c)
\end{verbatim}

  The returned ilist may share a common tail with the argument ilist.

  dilist may be any ilist, either proper or dotted:

\begin{verbatim}
(itake-right (iq ipair 1 (ipair 2 (ipair 3 'd))) 2) => (2 3 . d)
(idrop-right (ipair 1 (ipair 2 (ipair 3 'd))) 2)    => (1)
(itake-right (ipair 1 (ipair 2 (ipair 3 'd))) 0)    => d
(idrop-right (ipair 1 (ipair 2 (ipair 3 'd))) 0)    => (1 2 3)
\end{verbatim}

  For a legal i, \texttt{itake-right} and \texttt{idrop-right}
  partition the ilist in a manner which can be inverted with
  \texttt{iappend}:

\begin{verbatim}
(iappend (itake dilist i) (idrop dilist i)) = dilist
\end{verbatim}

  \texttt{itake-right}'s return value is guaranteed to share a common
  tail with dilist.
\end{entry}

\begin{entry}{%
  \Proto{isplit-at}{ x i}{procedure}{ilist object}}

  \texttt{isplit-at} splits the ilist x at index i, returning an ilist
  of the first i elements, and the remaining tail. It is equivalent to

\begin{verbatim}
(values (itake x i) (idrop x i))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ilast}{ ipair}{procedure}{object}
  \Proto{last-ipair}{ ipair}{procedure}{ipair}}

  Returns the last
  element of the non-empty, possibly dotted, ilist ipair.
  \texttt{last-ipair} returns the last ipair in the non-empty ilist
  pair.

\begin{verbatim}
(ilast (iq a b c))      => c
(last-ipair (iq a b c)) => (c)
\end{verbatim}
\end{entry}

\subsubsection{Miscellaneous: length, append, concatenate, reverse, zip \& count}

\begin{entry}{%
  \Proto{ilength}{ilist}{procedure}{integer}}

  Returns the
  length of its argument. It is an error to pass a value to
  \texttt{ilength} which is not a proper ilist
  (\texttt{()}-terminated).

  The length of a proper ilist is a non-negative integer n such that
  \texttt{icdr} applied n times to the ilist produces the empty list.
\end{entry}

\begin{entry}{%
  \Proto{iappend}{ ilist$_1$ \ldots}{procedure}{ilist}}

  Returns an ilist consisting of the elements of ilist$_1$ followed by
  the elements of the other ilist parameters.

\begin{verbatim}
(iappend (iq x) (iq y))        =>  (x y)
(iappend (iq a) (iq b c d))    =>  (a b c d)
(iappend (iq a (b)) (iq (c)))  =>  (a (b) (c))
\end{verbatim}

  The resulting ilist is always newly allocated, except that it shares
  structure with the final ilist$_i$ argument. This last argument may
  be any value at all; an improper ilist results if it is not a proper
  ilist. All other arguments must be proper ilists.

\begin{verbatim}
(iappend (iq a b) (ipair 'c 'd))  =>  (a b c . d)
(iappend '() 'a)           =>  a
(iappend (iq x y))         =>  (x y)
(iappend)                  =>  ()
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iconcatenate}{ ilist-of-ilists}{procedure}{value}}

Appends the elements of its argument together. That is,
  \texttt{iconcatenate} returns

\begin{verbatim}
(iapply iappend ilist-of-ilists)
\end{verbatim}

  or, equivalently,

\begin{verbatim}
(ireduce-right iappend '() ilist-of-ilists)
\end{verbatim}

  Note that some Scheme implementations do not support passing more
  than a certain number (\emph{e.g.}, 64) of arguments to an n-ary
  procedure. In these implementations, the \texttt{(iapply\ iappend\
    ...)} idiom would fail when applied to long lists, but
  \texttt{iconcatenate} would continue to function properly.

  As with \texttt{iappend}, the last element of the input list may be
  any value at all.
\end{entry}

\begin{entry}{%
  \Proto{ireverse}{ ilist}{procedure}{ilist}}

  Returns a
  newly allocated ilist consisting of the elements of ilist in reverse
  order.

\begin{verbatim}
(ireverse (iq a b c)) =>  (c b a)
(ireverse (iq a (b c) d (e (f))))
    =>  ((e (f)) d (b c) a)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iappend-reverse}{rev-head tail}{procedure}{ilist}}

  \texttt{iappend-reverse} returns \texttt{(iappend\ (ireverse\
    rev-head)\ tail)}. It is provided because it is a common
  operation---a common list-processing style calls for this exact
  operation to 
  transfer values accumulated in reverse order onto the front of
  another ilist, and because the implementation is significantly more
  efficient than the simple composition it replaces.  (But note that
  this pattern of iterative computation followed by a reverse can
  frequently be rewritten as a recursion, dispensing with the
  \texttt{reverse} and \texttt{iappend-reverse} steps, and shifting
  temporary, intermediate storage from the heap to the stack, which is
  typically a win for reasons of cache locality and eager storage
  reclamation.)
\end{entry}

\begin{entry}{%
  \Proto{izip}{ ilist$_1$ ilist$_2$ \ldots}{procedure}{ilist}}

\begin{verbatim}
(lambda ilists (iapply imap ilist ilists))
\end{verbatim}

  If \texttt{izip} is passed n ilists, it returns an ilist as long as
  the shortest of these ilists, each element of which is an n-element
  ilist comprised of the corresponding elements from the parameter
  ilists.

\begin{verbatim}
(izip (iq one two three) 
     (iq 1 2 3)
     (iq odd even odd even odd even odd even))
    => ((one 1 odd) (two 2 even) (three 3 odd))

(izip (iq 1 2 3)) => ((1) (2) (3))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iunzip1}{ ilist}{procedure}{ilist}
  \Proto{iunzip2}{ ilist}{procedure}{ilist ilist}
  \Proto{iunzip3}{ ilist}{procedure}{ilist ilist ilist}
  \Proto{iunzip4}{ ilist}{procedure}{ilist ilist ilist ilist}
  \Proto{iunzip5}{ ilist}{procedure}{ilist ilist ilist ilistilist}}

  \texttt{iunzip1}
  takes an ilist of ilists, where every ilist must contain at least
  one element, and returns an ilist containing the initial element of
  each such ilist. That is, it returns \texttt{(imap\ icar\
    ilists)}. \texttt{iunzip2} takes an ilist of ilists, where every
  ilist must contain at least two elements, and returns two values: an
  ilist of the first elements, and an ilist of the second
  elements. \texttt{iunzip3} does the same for the first three
  elements of the ilists, and so forth.

\begin{verbatim}
(iunzip2 (iq (1 one) (2 two) (3 three))) =>
    (1 2 3) 
    (one two three)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{icount}{ pred ilist$_1$ ilist$_2$ \ldots}{procedure}{integer}}

  pred is a procedure taking as many
  arguments as there are ilists and returning a single value. It is
  applied element-wise to the elements of the ilists, and a count is
  tallied of the number of elements that produce a true value. This
  count is returned. \texttt{count} is ``iterative'' in that it is
  guaranteed to apply pred to the ilist elements in a left-to-right
  order. The counting stops when the shortest ilist expires.

\begin{verbatim}
(count even? (iq 3 1 4 1 5 9 2 5 6)) => 3
(count < (iq 1 2 4 8) (iq 2 4 6 8 10 12 14 16)) => 3
\end{verbatim}
\end{entry}

\subsubsection{{Fold, unfold, and  map}}

\begin{entry}{%
  \Proto{ifold}{ kons knil ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

The fundamental ilist iterator.

  First, consider the single ilist-parameter case. If ilist$_1$ =
  (e$_1$ e$_2$ \ldots e\textsubscript{n}), then this procedure
  returns

  \texttt{(kons\ en\ ...\ (kons\ e2\ (kons\ e1\ knil))\ ...\ )}

  That is, it obeys the (tail) recursion

\begin{verbatim}
(ifold kons knil lis) = (ifold kons (kons (icar lis) knil) (icdr lis))
(ifold kons knil '()) = knil
\end{verbatim}

  Examples:

\begin{verbatim}
(ifold + 0 lis)           ; Add up the elements of LIS.

(ifold ipair '() lis)       ; Reverse LIS.

(ifold ipair tail rev-head) ; See APPEND-REVERSE.

;; How many symbols in LIS?
(ifold (lambda (x count) (if (symbol? x) (+ count 1) count))
      0
      lis)

;; Length of the longest string in LIS:
(ifold (lambda (s max-len) (max max-len (string-length s)))
      0
      lis)
\end{verbatim}

  If n ilist arguments are provided, then the kons function must take
  n+1 parameters: one element from each ilist, and the ``seed'' or
  fold state, which is initially knil. The fold operation terminates
  when the shortest ilist runs out of values:

\begin{verbatim}
(ifold ipair* '() (iq a b c) (iq 1 2 3 4 5)) => (c 3 b 2 a 1)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ifold-right}{ kons knil ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

The fundamental ilist recursion operator.

  First, consider the single ilist-parameter case. If ilist$_1$ =
  \texttt{(e1\ e2\ ...\ en)}, then this procedure returns

  \texttt{\ (kons\ e1\ (kons\ e2\ ...\ (kons\ en\ knil)))}

  That is, it obeys the recursion

\begin{verbatim}
(ifold-right kons knil lis) = (kons (icar lis) (ifold-right kons knil (icdr lis)))
(ifold-right kons knil '()) = knil
\end{verbatim}

  Examples:

\begin{verbatim}
(ifold-right ipair '() lis)       ; Copy LIS.

;; Filter the even numbers out of LIS.
(ifold-right (lambda (x l) (if (even? x) (ipair x l) l)) '() lis))
\end{verbatim}

  If n ilist arguments are provided, then the kons procedure must take
  n+1 parameters: one element from each ilist, and the ``seed'' or
  fold state, which is initially knil. The fold operation terminates
  when the shortest ilist runs out of values:

\begin{verbatim}
(ifold-right ipair* '() (iq a b c) (iq 1 2 3 4 5)) => (a 1 b 2 c 3)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ipair-fold}{ kons knil ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

  Analogous to \texttt{fold}, but kons is
  applied to successive sub-ilists of the ilists, rather than
  successive elements---that is, kons is applied to the ipairs
  making up the lists, giving this (tail) recursion:

\begin{verbatim}
(ipair-fold kons knil lis) = (let ((tail (icdr lis)))
                              (ipair-fold kons (kons lis knil) tail))
(ipair-fold kons knil '()) = knil
\end{verbatim}

  Example:

\begin{verbatim}
(ipair-fold ipair '() (iq a b c)) => ((c) (b c) (a b c))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ipair-fold-right}{ kons knil ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

  Holds the same relationship with
  \texttt{ifold-right} that \texttt{ipair-fold} holds with
  \texttt{ifold}. Obeys the recursion

\begin{verbatim}
(ipair-fold-right kons knil lis) = 
    (kons lis (ipair-fold-right kons knil (icdr lis)))
(ipair-fold-right kons knil '()) = knil
\end{verbatim}

  Example:

\begin{verbatim}
(ipair-fold-right ipair '() (iq a b c)) => ((a b c) (b c) (c))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ireduce}{ f ridentity ilist}{procedure}{value}}

  \texttt{ireduce} is a variant of \texttt{ifold}.

  ridentity should be a ``right identity'' of the procedure f---that
  is, for any value x acceptable to f,

\begin{verbatim}
(f x ridentity) = x
\end{verbatim}

  \texttt{ireduce} has the following definition:

  If ilist = (), return ridentity;\\
  Otherwise, return \texttt{(ifold\ f\ (icar\ ilist)\ (icdr\ ilist))}.

  \ldots{}in other words, we compute \texttt{(ifold\ f\ ridentity\
    ilist)}.

  Note that ridentity is used \emph{only} in the empty-list case. You
  typically use \texttt{ireduce} when applying f is expensive and
  you'd like to avoid the extra application incurred when
  \texttt{ifold} applies f to the head of ilist and the identity
  value, redundantly producing the same value passed in to f. For
  example, if f involves searching a file directory or performing a
  database query, this can be significant. In general, however,
  \texttt{ifold} is useful in many contexts where \texttt{ireduce} is
  not (consider the examples given in the \texttt{ifold}
  definition---only one of the five folds uses a function with a right 
  identity. The other four may not be performed with
  \texttt{ireduce}).

\begin{verbatim}
;; take the max of an ilist of non-negative integers.
(ireduce max 0 nums) ; i.e., (iapply max 0 nums)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ireduce-right}{ f ridentity ilist}{procedure}{value}}

\texttt{ireduce-right} is the fold-right variant of
  \texttt{ireduce}. It obeys the following definition:

\begin{verbatim}
(ireduce-right f ridentity '()) = ridentity
(ireduce-right f ridentity (iq e1)) = (f e1 ridentity) = e1
(ireduce-right f ridentity (iq e1 e2 ...)) =
    (f e1 (ireduce f ridentity (e2 ...)))
\end{verbatim}

  \ldots{}in other words, we compute \texttt{(ifold-right\ f\
    ridentity\ ilist)}.

\begin{verbatim}
;; Append a bunch of ilists together.
;; I.e., (iapply iappend ilist-of-ilists)
(ireduce-right iappend '() ilist-of-ilists)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iunfold}{ p f g seed {[}tail-gen{]}}{procedure}{ilist}}

\texttt{iunfold} is best described by its basic recursion:

\begin{verbatim}
(iunfold p f g seed) = 
    (if (p seed) (tail-gen seed)
        (ipair (f seed)
              (iunfold p f g (g seed))))
\end{verbatim}

\begin{description}
  \tightlist
\item[ p ] Determines when to stop unfolding.
\item[ f ] Maps each seed value to the corresponding ilist element.
\item[ g ] Maps each seed value to next seed value.
\item[ seed ] The ``state'' value for the unfold.
\item[ tail-gen ] Creates the tail of the ilist; defaults to
  \texttt{(lambda\ (x)\ \textquotesingle{}())}
\end{description}

In other words, we use g to generate a sequence of seed values

seed, g(seed), g\textsuperscript{2}(seed), g\textsuperscript{3}(seed),
\ldots{}

These seed values are mapped to ilist elements by f, producing the
elements of the result ilist in a left-to-right order. P says when to
stop.

\texttt{iunfold} is the fundamental recursive ilist constructor, just
as \texttt{ifold-right} is the fundamental recursive ilist
consumer. While \texttt{iunfold} may seem a bit abstract to novice
functional programmers, it can be used in a number of ways:

\begin{verbatim}
;; Ilist of squares: 1^2 ... 10^2
(iunfold (lambda (x) (> x 10))
        (lambda (x) (* x x))
    (lambda (x) (+ x 1))
    1)
        
(iunfold null-ilist? icar icdr lis) ; Copy a proper ilist.

;; Read current input port into an ilist of values.
(iunfold eof-object? values (lambda (x) (read)) (read))

;; Copy a possibly non-proper ilist:
(iunfold not-ipair? icar icdr lis 
              values)

;; Append HEAD onto TAIL:
(iunfold null-ilist? icar icdr head 
              (lambda (x) tail))
\end{verbatim}

Interested functional programmers may enjoy noting that
\texttt{ifold-right} and \texttt{iunfold} are in some sense inverses.
That is, given operations knull?, kar, kdr, kons, and knil satisfying

\texttt{(kons\ (kar\ x)\ (kdr\ x))} = \texttt{x} and \texttt{(knull?\
  knil)} = \texttt{\#t}

then

\texttt{(ifold-right\ kons\ knil\ (iunfold\ knull?\ kar\ kdr\ x))} = x

and

\texttt{(iunfold\ knull?\ kar\ kdr\ (ifold-right\ kons\ knil\ x))} =
x.

This combinator sometimes is called an ``anamorphism;'' when an
explicit tail-gen procedure is supplied, it is called an
``apomorphism.''
\end{entry}

\begin{entry}{%
  \Proto{iunfold-right}{ p f g seed tail}{procedure}{ilist}
  \Rproto{iunfold-right}{ p f g seed}{procedure}{ilist}}

\texttt{iunfold-right} constructs an ilist with the
  following loop:

\begin{verbatim}
(let lp ((seed seed) (lis tail))
  (if (p seed) lis
      (lp (g seed)
          (ipair (f seed) lis))))
\end{verbatim}

\begin{description}
  \tightlist
\item[ p ] Determines when to stop unfolding.
\item[ f ] Maps each seed value to the corresponding ilist element.
\item[ g ] Maps each seed value to next seed value.
\item[ seed ] The ``state'' value for the unfold.
\item[ tail ] ilist terminator; defaults to
  \texttt{\textquotesingle{}()}.
\end{description}

In other words, we use g to generate a sequence of seed values

seed, g(seed), g\textsuperscript{2}(seed), g\textsuperscript{3}(seed),
\ldots{}

These seed values are mapped to ilist elements by f, producing the
elements of the result ilist in a right-to-left order. P says when to
stop.

\texttt{iunfold-right} is the fundamental iterative ilist constructor,
just as \texttt{ifold} is the fundamental iterative ilist consumer.
While \texttt{iunfold-right} may seem a bit abstract to novice
functional programmers, it can be used in a number of ways:

\begin{verbatim}
;; Ilist of squares: 1^2 ... 10^2
(iunfold-right zero? 
              (lambda (x) (* x x))
              (lambda (x) (- x 1))
              10)
    
;; Reverse a proper ilist.
(iunfold-right null-ilist? icar icdr lis)

;; Read current input port into an ilist of values.
(iunfold-right eof-object? values (lambda (x) (read)) (read))

;; (iappend-reverse rev-head tail)
(iunfold-right null-ilist? icar icdr rev-head tail)
\end{verbatim}

Interested functional programmers may enjoy noting that \texttt{ifold}
and \texttt{iunfold-right} are in some sense inverses. That is, given
operations knull?, kar, kdr, kons, and knil satisfying

\texttt{(kons\ (kar\ x)\ (kdr\ x))} = \texttt{x} and \texttt{(knull?\
  knil)} = \texttt{\#t}

then

\texttt{(ifold\ kons\ knil\ (iunfold-right\ knull?\ kar\ kdr\ x))} = x

and

\texttt{(iunfold-right\ knull?\ kar\ kdr\ (ifold\ kons\ knil\ x))} =
x.

This combinator presumably has some pretentious mathematical name;
interested readers are invited to communicate it to the author.
\end{entry}

\begin{entry}{%
  \Proto{imap}{ proc ilist$_1$ ilist$_2$ \ldots}{procedure}{ilist}}

  proc is a procedure taking as many arguments as there are
  ilist arguments and returning a single value. \texttt{imap} applies
  proc element-wise to the elements of the ilists and returns an ilist
  of the results, in order. The dynamic order in which proc is applied
  to the elements of the ilists is unspecified.

\begin{verbatim}
(imap icadr (iq (a b) (d e) (g h))) =>  (b e h)

(imap (lambda (n) (expt n n))
     (iq 1 2 3 4 5))
    =>  (1 4 27 256 3125)

(imap + (iq 1 2 3) (iq 4 5 6)) =>  (5 7 9)

(let ((count 0))
  (imap (lambda (ignored)
         (set! count (+ count 1))
         count)
       (iq a b))) =>  (1 2) or (2 1)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ifor-each}{ proc ilist$_1$ ilist$_2$ \ldots}{procedure}{unspecified}}

The arguments to \texttt{ifor-each}
  are like the arguments to \texttt{imap}, but \texttt{ifor-each}
  calls proc for its side effects rather than for its values. Unlike
  \texttt{imap}, \texttt{ifor-each} is guaranteed to call proc on the
  elements of the ilists in order from the first element(s) to the
  last, and the value returned by \texttt{ifor-each} is unspecified.

\begin{verbatim}
(let ((v (make-vector 5)))
  (ifor-each (lambda (i)
              (vector-set! v i (* i i)))
            (iq 0 1 2 3 4))
  v)  =>  #(0 1 4 9 16)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iappend-map}{f ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

Equivalent to

  \texttt{\ (iapply\ iappend\ \ (imap\ f\ ilist1\ ilist2\ ...))}

  and

  \texttt{\ (iapply\ iappend\ (imap\ f\ ilist1\ ilist2\ ...))}

  Map f over the elements of the ilists, just as in the \texttt{imap}
  function. However, the results of the applications are appended
  together (using \texttt{iappend}) to make the final result.

  The dynamic order in which the various applications of f are made is
  not specified.

  Example:

\begin{verbatim}
(iappend-map (lambda (x) (ilist x (- x))) (iq 1 3 8))
    => (1 -1 3 -3 8 -8)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{imap-in-order}{f ilist$_1$ ilist$_2$ \ldots}{procedure}{ilist}}

  A variant of the \texttt{imap} procedure
  that guarantees to apply f across the elements of the ilist$_i$
  arguments in a left-to-right order. This is useful for mapping
  procedures that both have side effects and return useful values.
\end{entry}

\begin{entry}{%
  \Proto{ipair-for-each}{f ilist$_1$ ilist$_2$ \ldots}{procedure}{unspecific}}

  Like \texttt{ifor-each}, but f is
  applied to successive sub-ilists of the argument ilists. That is, f
  is applied to the cells of the ilists, rather than the ilists'
  elements. These applications occur in left-to-right order.

\begin{verbatim}
(ipair-for-each (lambda (ipair) (display ipair) (newline)) (iq a b c)) ==>
    (a b c)
    (b c)
    (c)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ifilter-map}{ f ilist$_1$ ilist$_2$ \ldots}{procedure}{ilist}}

  Like \texttt{imap}, but only true values are saved.

\begin{verbatim}
(ifilter-map (lambda (x) (and (number? x) (* x x))) (iq a 1 b 3 c 7))
    => (1 9 49)
\end{verbatim}

  The dynamic order in which the various applications of f are made is
  not specified.
\end{entry}

\subsubsection{{Filtering and partitioning}}

\begin{entry}{%
  \Proto{ifilter}{ pred ilist}{procedure}{ilist}}

  Return all
  the elements of ilist that satisfy predicate pred. The ilist is not
  disordered---elements that appear in the result ilist occur in the
  same order as they occur in the argument ilist. The returned ilist
  may share a common tail with the argument ilist. The dynamic order
  in which the various applications of pred are made is not specified.

\begin{verbatim}
(ifilter even? (iq 0 7 8 8 43 -4)) => (0 8 8 -4)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ipartition}{ pred ilist}{procedure}{ilist ilist}}

  Partitions the elements of ilist with predicate pred, and
  returns two values: the ilist of in-elements and the ilist of
  out-elements. The ilist is not disordered---elements occur in the
  result ilists in the same order as they occur in the argument
  ilist. The dynamic order in which the various applications of pred
  are made is not specified. One of the returned ilists may share a
  common tail with the argument ilist.

\begin{verbatim}
(ipartition symbol? (iq one 2 3 four five 6)) => 
    (one four five)
    (2 3 6)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iremove}{ pred ilist}{procedure}{ilist}}

  Returns
  ilist without the elements that satisfy predicate pred:

\begin{verbatim}
(lambda (pred ilist) (ifilter (lambda (x) (not (pred x))) ilist))
\end{verbatim}

  The ilist is not disordered---elements that appear in the result
  ilist occur in the same order as they occur in the argument
  ilist. The returned ilist may share a common tail with the argument
  ilist. The dynamic order in which the various applications of pred
  are made is not specified.

\begin{verbatim}
(iremove even? (iq 0 7 8 8 43 -4)) => (7 43)
\end{verbatim}
\end{entry}

\subsubsection{{Searching}}

The following procedures all search ilists for a leftmost element
satisfying some criteria. This means they do not always examine the
entire ilist; thus, there is no efficient way for them to reliably
detect and signal an error when passed a dotted ilist. Here are the
general rules describing how these procedures work when applied to
different kinds of ilists:

\begin{description}
\item[ Proper ilists: ]
The standard, canonical behavior happens in this case.
\item[ Dotted ilists: ]
It is an error to pass these procedures a dotted ilist that does not
contain an element satisfying the search criteria. That is, it is an
error if the procedure has to search all the way to the end of the
dotted ilist. However, this SRFI does \emph{not} specify anything at all
about the behavior of these procedures when passed a dotted ilist
containing an element satisfying the search criteria. It may finish
successfully, signal an error, or perform some third action. Different
implementations may provide different functionality in this case; code
which is compliant with this SRFI may not rely on any particular
behavior. Future SRFIs may refine this SRFI to define specific behavior
in this case.

In brief, compliant code may not pass a dotted ilist argument to these
procedures.
\end{description}

Here are some examples, using the \texttt{ifind} and \texttt{iany}
procedures as canonical representatives:

\begin{verbatim}
;; Proper ilist — success
(ifind even? (iq 1 2 3))    => 2
(iany  even? (iq 1 2 3))    => #t

;; proper ilist — failure
(ifind even? (iq 1 7 3))    => #f
(iany  even? (iq 1 7 3))    => #f

;; Failure is error on a dotted ilist.
(ifind even? (ipair 1 (ipair 3 'x)))    => error
(iany  even? (ipair 1 (ipair 3 'x)))    => error

;; The dotted ilist contains an element satisfying the search.
;; This case is not specified — it could be success, an error, 
;; or some third possibility.
(ifind even? (ipair 1 (ipair 2 'x)))    => error/undefined
(iany  even? (ipair 1 (ipair 2 'x)))    => error/undefined ; success, error or other.
\end{verbatim}

\begin{entry}{%
  \Proto{ifind}{ pred ilist}{procedure}{value}}

  Return the
  first element of ilist that satisfies predicate pred; \schfalse{} if no
  element does.

\begin{verbatim}
(ifind even? (iq 3 1 4 1 5 9)) => 4
\end{verbatim}

  Note that \texttt{ifind} has an ambiguity in its lookup
  semantics---if \texttt{ifind} returns \schfalse{}, you cannot tell
  (in 
  general) if it found a \schfalse{} element that satisfied pred, or
  if it did not find any element at all. In many situations, this
  ambiguity cannot arise---either the ilist being searched is known
  not to contain any \schfalse{} elements, or the ilist is guaranteed
  to have an element satisfying pred.  However, in cases where this
  ambiguity can arise, you should use \texttt{ifind-tail} instead of
  \texttt{ifind}---\texttt{ifind-tail} has no such ambiguity:

\begin{verbatim}
(cond ((ifind-tail pred lis) => (lambda (ipair) ...)) ; Handle (icar ipair)
      (else ...)) ; Search failed.
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ifind-tail}{ pred ilist}{procedure}{ipair \textrm{or} \schfalse}}

  Return the first ipair of ilist whose icar satisfies pred. If no
  ipair does, return \schfalse{}.

  \texttt{ifind-tail} can be viewed as a general-predicate variant of
  the \texttt{imember} function.

  Examples:

\begin{verbatim}
(ifind-tail even? (iq 3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
(ifind-tail even? (iq 3 1 37 -5)) => #f

;; IMEMBER X LIS:
(ifind-tail (lambda (elt) (equal? x elt)) lis)
\end{verbatim}

  \texttt{Ifind-tail} is essentially \texttt{idrop-while}, where the
  sense of the predicate is inverted: \texttt{Ifind-tail} searches
  until it finds an element satisfying the predicate;
  \texttt{idrop-while} searches until it finds an element that
  \emph{doesn't} satisfy the predicate.
\end{entry}

\begin{entry}{%
  \Proto{itake-while}{ pred ilist}{procedure}{ilist}}

  Returns
  the longest initial prefix of ilist whose elements all satisfy the
  predicate pred.

\begin{verbatim}
(itake-while even? (iq 2 18 3 10 22 9)) => (2 18)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{idrop-while}{ pred ilist}{procedure}{ilist}}

  idrops
  the longest initial prefix of ilist whose elements all satisfy the
  predicate pred, and returns the rest of the ilist.

\begin{verbatim}
(idrop-while even? (iq 2 18 3 10 22 9)) => (3 10 22 9)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ispan}{ pred ilist}{procedure}{ilist ilist}
  \Proto{ibreak}{ pred ilist}{procedure}{ilist ilist}}

  \texttt{ispan} splits the ilist into the longest initial prefix
  whose elements all satisfy pred, and the remaining
  tail. \texttt{ibreak} inverts the sense of the predicate: the tail
  commences with the first element of the input ilist that satisfies
  the predicate.

  In other words: \texttt{ispan} finds the initial span of elements
  satisfying pred, and \texttt{ibreak} breaks the ilist at the first
  element satisfying pred.

  \texttt{ispan} is equivalent to

\begin{verbatim}
(values (itake-while pred ilist) 
        (idrop-while pred ilist))
\end{verbatim}

\begin{verbatim}
(ispan even? (iq 2 18 3 10 22 9)) =>
  (2 18)
  (3 10 22 9)

(ibreak even? (iq 3 1 4 1 5 9)) =>
  (3 1)
  (4 1 5 9)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{iany}{ pred ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

  Applies the predicate across the ilists, returning true if
  the predicate returns true on any application.

  If there are n ilist arguments ilist$_1$ \ldots{}
  ilist\textsubscript{n}, then pred must be a procedure taking n
  arguments and returning a boolean result.

  \texttt{iany} applies pred to the first elements of the ilist$_i$
  parameters. If this application returns a true value, \texttt{iany}
  immediately returns that value. Otherwise, it iterates, applying
  pred to the second elements of the ilist$_i$ parameters, then the
  third, and so forth. The iteration stops when a true value is
  produced or one of the ilists runs out of values; in the latter
  case, \texttt{iany} returns \schfalse{}.  The application of pred
  to the last element of the ilists is a tail call.

  Note the difference between \texttt{ifind} and
  \texttt{iany}---\texttt{ifind} returns the element that satisfied
  the predicate; 
  \texttt{iany} returns the true value that the predicate produced.

  Like \texttt{ievery}, \texttt{iany}'s name does not end with a
  question mark---this is to indicate that it does not return a
  simple boolean (\texttt{\#t} or \schfalse{}), but a general value.

\begin{verbatim}
(iany integer? (iq a 3 b 2.7))   => #t
(iany integer? (iq a 3.1 b 2.7)) => #f
(iany < (iq 3 1 4 1 5)
       (iq 2 7 1 8 2)) => #t
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ievery}{ pred ilist$_1$ ilist$_2$ \ldots}{procedure}{value}}

  Applies the predicate across the ilists,
  returning true if the predicate returns true on every application.

  If there are n ilist arguments ilist$_1$ \ldots
  ilist\textsubscript{n}, then pred must be a procedure taking n
  arguments and returning a boolean result.

  \texttt{ievery} applies pred to the first elements of the ilist$_i$
  parameters. If this application returns \schfalse{}, \texttt{ievery}
  immediately returns \schfalse{}. Otherwise, it iterates, applying pred to
  the second elements of the ilist$_i$ parameters, then the third, and
  so forth. The iteration stops when a \schfalse{} value is produced or one
  of the ilists runs out of values. In the latter case,
  \texttt{ievery} returns the true value produced by its final
  application of pred. The application of pred to the last element of
  the ilists is a tail call.

  If one of the ilist$_i$ has no elements, \texttt{ievery} simply
  returns \texttt{\#t}.

  Like \texttt{iany}, \texttt{ievery}'s name does not end with a
  question mark---this is to indicate that it does not return a
  simple boolean (\texttt{\#t} or \schfalse{}), but a general value.
\end{entry}

\begin{entry}{%
  \Proto{ilist-index}{ pred ilist$_1$ ilist$_2$ \ldots}{procedure}{integer
    \textrm{or} \schfalse{}}} 

  Return the index of the leftmost
  element that satisfies pred.

  If there are n ilist arguments ilist$_1$ \ldots
  ilist\textsubscript{n}, then pred must be a function taking n
  arguments and returning a boolean result.

  \texttt{ilist-index} applies pred to the first elements of the
  ilist$_i$ parameters. If this application returns true,
  \texttt{ilist-index} immediately returns zero. Otherwise, it
  iterates, applying pred to the second elements of the ilist$_i$
  parameters, then the third, and so forth. When it finds a tuple of
  ilist elements that cause pred to return true, it stops and returns
  the zero-based index of that position in the ilists.

  The iteration stops when one of the ilists runs out of values; in
  this case, \texttt{ilist-index} returns \schfalse{}.

\begin{verbatim}
(ilist-index even? (iq 3 1 4 1 5 9)) => 2
(ilist-index < (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)) => 1
(ilist-index = (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)) => #f
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{imember}{ x ilist =}{procedure}{ilist}
  \Rproto{imember}{ x ilist}{procedure}{ilist}
  \Proto{imemq}{ x ilist}{procedure}{ilist}
  \Proto{imemv}{ x ilist}{procedure}{ilist}}

  These procedures
  return the first sub-ilist of ilist whose icar is x, where the
  sub-ilists of ilist are the non-empty ilists returned by
  \texttt{(idrop\ ilist\ i)} for i less than the length of ilist. If x
  does not occur in ilist, then \schfalse{} is
  returned. \texttt{imemq} uses \texttt{eq?} to compare x with the
  elements of ilist, while \texttt{imemv} uses \texttt{eqv?}, and
  \texttt{imember} uses \texttt{equal?}.

\begin{verbatim}
    (imemq 'a (iq a b c))           =>  (a b c)
    (imemq 'b (iq a b c))           =>  (b c)
    (imemq 'a (iq b c d))           =>  #f
    (imemq (list 'a)
            (ilist 'b '(a) 'c))     =>  #f
    (imember (list 'a)
            (ilist 'b '(a) 'c)))    =>  ((a) c)
    (imemq 101 (iq 100 101 102))    =>  *unspecified*
    (imemv 101 (iq 100 101 102))    =>  (101 102)
\end{verbatim}

  The comparison procedure is used to compare the elements e$_i$ of
  ilist to the key x in this way:

  \texttt{\ (=\ x\ ei)\ \ \ \ \ \ \ ;\ ilist\ is\ (E1\ ...\ En)}

  That is, the first argument is always x, and the second argument is
  one of the ilist elements. Thus one can reliably find the first
  element of ilist that is greater than five with \texttt{(imember\ 5\
    ilist\ \textless{})}

  Note that fully general ilist searching may be performed with the
  \texttt{ifind-tail} and \texttt{ifind} procedures, \emph{e.g.}

\begin{verbatim}
(ifind-tail even? ilist) ; Find the first elt with an even key.
\end{verbatim}
\end{entry}

\subsubsection{{Deletion}}

\begin{entry}{%
  \Proto{idelete}{x ilist {[}={]}}{procedure}{ilist}}

  \texttt{idelete} uses the comparison procedure =, which defaults to
  \texttt{equal?}, to find all elements of ilist that are equal to x,
  and deletes them from ilist. The dynamic order in which the various
  applications of = are made is not specified.

  The ilist is not disordered---elements that appear in the result
  ilist occur in the same order as they occur in the argument
  ilist. The result may share a common tail with the argument ilist.

  Note that fully general element deletion can be performed with the
  \texttt{iremove} procedures, \emph{e.g.}:

\begin{verbatim}
;; idelete all the even elements from LIS:
(iremove even? lis)
\end{verbatim}

  The comparison procedure is used in this way: \texttt{(=\ x\
    ei)}. That is, x is always the first argument, and an ilist
  element is always the second argument. The comparison procedure will
  be used to compare each element of ilist exactly once; the order in
  which it is applied to the various e$_i$ is not specified. Thus, one
  can reliably remove all the numbers greater than five from an ilist
  with \texttt{(idelete\ 5\ ilist\ \textless{})}
\end{entry}

\begin{entry}{%
  \Proto{idelete-duplicates}{ilist =}{procedure}{ilist}
  \Rproto{idelete-duplicates}{ilist}{procedure}{ilist}}

  \texttt{idelete-duplicates} removes duplicate elements from
  the ilist argument. If there are multiple equal elements in the
  argument ilist, the result ilist only contains the first or leftmost
  of these elements in the result. The order of these surviving
  elements is the same as in the original
  ilist---\texttt{idelete-duplicates} does not disorder the ilist
  (hence it is 
  useful for ``cleaning up'' immutable association lists).

  The = parameter is used to compare the elements of the ilist; it
  defaults to \texttt{equal?}. If x comes before y in ilist, then the
  comparison is performed \texttt{(=\ x\ y)}. The comparison procedure
  will be used to compare each pair of elements in ilist no more than
  once; the order in which it is applied to the various pairs is not
  specified.

  Implementations of \texttt{idelete-duplicates} are allowed to share
  common tails between argument and result ilists---for example, if
  the ilist argument contains only unique elements, it may simply
  return exactly this ilist.

  Be aware that, in general, \texttt{idelete-duplicates} runs in time
  $O(n^2)$ for n-element ilists. Uniquifying long
  ilists can be accomplished in $O(n \lg n)$ time by sorting the ilist to
  bring equal elements together, then using a linear-time algorithm to
  remove equal elements. Alternatively, one can use algorithms based
  on element-marking, with linear-time results.

\begin{verbatim}
(idelete-duplicates (iq a b a c a b c z)) => (a b c z)

;; Clean up an ialist:
(idelete-duplicates (iq (a . 3) (b . 7) (a . 9) (c . 1))
                   (lambda (x y) (eq? (icar x) (icar y))))
    => ((a . 3) (b . 7) (c . 1))
\end{verbatim}
\end{entry}

\subsubsection{{Immutable association lists}}

An ``immutable association list'' (or ``ialist'') is an ilist of ipairs.
The icar of each ipair contains a key value, and the icdr contains the
associated data value. They can be used to construct simple look-up
tables in Scheme. Note that ialists are probably inappropriate for
performance-critical use on large data; in these cases, immutable maps
or some other alternative should be employed.

\begin{entry}{%
  \Proto{iassoc}{ key ialist =}{procedure}{ipair \textrm{or} \schfalse{}}
  \Rproto{iassoc}{ key ialist}{procedure}{ipair \textrm{or} \schfalse{}}
  \Proto{iassq}{ key ialist}{procedure}{ipair \textrm{or} \schfalse{}}
  \Proto{iassv}{ key ialist}{procedure}{ipair \textrm{or} \schfalse{}}}

  ialist must
  be an immutable association list---an ilist of ipairs.  These
  procedures find the first ipair in ialist whose icar field is key,
  and returns that ipair. If no ipair in ialist has key as its icar,
  then \schfalse{} is returned. \texttt{iassq} uses \texttt{eq?} to
  compare key with the icar fields of the ipairs in ialist, while
  \texttt{iassv} uses \texttt{eqv?} and \texttt{iassoc} uses
  \texttt{equal?}.

\begin{verbatim}
(define e (iq (a 1) (b 2) (c 3)))
(iassq 'a e)                               =>  (a 1)
(iassq 'b e)                               =>  (b 2)
(iassq 'd e)                               =>  #f
(iassq (ilist 'a) (iq ((a)) ((b)) ((c))))  =>  #f
(iassoc '(a) (ilist '((a)) '((b)) '((c)))) =>  ((a))
(iassq 5 (iq (2 3) (5 7) (11 13)))     =>  *unspecified*
(iassv 5 (iq (2 3) (5 7) (11 13)))     =>  (5 7)
\end{verbatim}

  The comparison procedure is used to compare the elements e$_i$ of
  ilist to the key parameter in this way:

  \texttt{\ (=\ key\ (icar\ ei))\ \ ;\ ilist\ is\ (E1\ ...\ En)}

  That is, the first argument is always key, and the second argument
  is one of the ilist elements. Thus one can reliably find the first
  entry of ialist whose key is greater than five with \texttt{(iassoc\
    5\ ialist\ \textless{})}

  Note that fully general ialist searching may be performed with the
  \texttt{ifind-tail} and \texttt{ifind} procedures, \emph{e.g.}

\begin{verbatim}
;; Look up the first association in ialist with an even key:
(ifind (lambda (a) (even? (icar a))) ialist)
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{ialist-cons}{ key datum ialist}{procedure}{ialist}}

\begin{verbatim}
(lambda (key datum ialist) (ipair (ipair key datum) ialist))
\end{verbatim}

  Construct a new ialist entry mapping key -\textgreater{} datum onto
  ialist.
\end{entry}
\begin{entry}{%
  \Proto{ialist-delete}{key ialist =}{procedure}{ialist}
  \Rproto{ialist-delete}{key ialist}{procedure}{ialist}}

  \texttt{ialist-delete} deletes all associations from ialist
  with the given key, using key-comparison procedure =, which defaults
  to \texttt{equal?}. The dynamic order in which the various
  applications of = are made is not specified.

  Return values may share common tails with the ialist argument. The
  ialist is not disordered---elements that appear in the result
  ialist occur in the same order as they occur in the argument ialist.

  The comparison procedure is used to compare the element keys k$_i$
  of ialist's entries to the key parameter in this way: \texttt{(=\
    key\ ki)}. Thus, one can reliably remove all entries of ialist
  whose key is greater than five with \texttt{(ialist-delete\ 5\
    ialist\ \textless{})}
\end{entry}

\subsubsection{{Replacement}}

These two procedures are analogues of the primitive side-effect
operations on pairs, \texttt{set-car!} and \texttt{set-cdr!}.

\begin{entry}{%
  \Proto{replace-icar}{ ipair object}{procedure}{ipair}}

  This
  procedure returns an ipair with object in the icar field and the
  icdr of ipair in the icdr field.
\end{entry}

\begin{entry}{%
  \Proto{replace-icdr}{ ipair object}{procedure}{ipair}}

  This
  procedure returns an ipair with object in the icdr field and the
  icar of ipair in the icar field.
\end{entry}

\subsubsection{{Conversion}}

These procedures convert between mutable and immutable pair structures.

\begin{entry}{%
  \Proto{pair->ipair}{ pair}{procedure}{ipair}
  \Proto{ipair->pair}{ ipair}{procedure}{pair}}

These procedures, which are inverses, return an ipair and a pair
respectively that have the same (i)car and (i)cdr fields as the
argument.
\end{entry}

\begin{entry}{%
  \Proto{list->ilist}{ flist}{procedure}{dilist}
  \Proto{ilist->list}{ dilist}{procedure}{flist}}

  These procedures
  return an ilist and a list respectively that have the same elements
  as the argument. The tails of dotted (i)lists are preserved in the
  result, which makes the procedures not inverses when the tail of a
  dotted ilist is a list or vice versa. The empty list is converted to
  itself.

  It is an error to apply \texttt{list-\textgreater{}ilist} to a
  circular list.
\end{entry}

\begin{entry}{%
  \Proto{tree->itree}{ object}{procedure}{object}
  \Proto{itree->tree}{ object}{procedure}{object}}

  These
  procedures walk a tree of pairs or ipairs respectively and make a
  deep copy of it, returning an isomorphic tree containing ipairs or
  pairs respectively. The result may share structure with the
  argument. If the argument is not of the expected type, it is
  returned.

  These procedures are not inverses in the general case. For example,
  a pair of ipairs would be converted by
  \texttt{tree-\textgreater{}itree} to an ipair of ipairs, which if
  converted by \texttt{itree-\textgreater{}tree} would produce a pair
  of pairs.
\end{entry}

\begin{entry}{%
  \Proto{gtree->itree}{ object}{procedure}{object}
  \Proto{gtree->tree}{ object}{procedure}{object}}

  These procedures walk a generalized tree consisting of pairs,
  ipairs, or a combination of both, and make a deep copy of it,
  returning an isomorphic tree containing only ipairs or pairs
  respectively. The result may share structure with the argument. If
  the argument is neither a pair nor an ipair, it is returned.
\end{entry}

\subsubsection{{Procedure Application}}\label{procedure-application}

This procedure allows a procedure to be applied to an ilist.

\begin{entry}{%
  \Proto{iapply}{ procedure object \ldots ilist}{procedure}{object}}

  The \texttt{iapply} procedure is an analogue of
  \texttt{apply} whose last argument is an ilist rather than a
  list. It is equivalent to \texttt{(apply\ }procedure object \ldots{}
  (\texttt{ilist-\textgreater{}list} ilist\texttt{))}, but may be
  implemented more efficiently.
\end{entry}

\subsubsection{{Comparators}}\label{comparators}

\begin{entry}{%
  \Vproto{ipair-comparator}{object}}

  The \texttt{ipair-comparator}
  object is a SRFI-114 comparator suitable for comparing ipairs. Note
  that it is \emph{not} a procedure. It compares pairs using
  \texttt{default-comparator} on their cars. If the cars are not
  equal, that value is returned. If they are equal,
  \texttt{default-comparator} is used on their cdrs and that value is
  returned.
\end{entry}

\begin{entry}{%
  \Vproto{ilist-comparator}{object}}
 
  The \texttt{ilist-comparator}
  object is a SRFI-114 comparator suitable for comparing ilists. Note
  that it is \emph{not} a procedure. It compares ilists
  lexicographically, as follows:

\begin{itemize}
  \tightlist
\item The empty ilist compares equal to itself.
\item The empty ilist compares less than any non-empty ilist.
\item Two non-empty ilists are compared by comparing their icars. If
  the icars are not equal when compared using
  \texttt{default-comparator}, then the result is the result of that
  comparison. Otherwise, the icdrs are compared using
  \texttt{ilist-comparator}.
\end{itemize}
\end{entry}

\begin{entry}{%
  \Proto{make-ilist-comparator}{ comparator}{procedure}{comparator}}

  The \texttt{make-ilist-comparator} procedure returns a
  comparator suitable for comparing ilists using element-comparator to
  compare the elements.
\end{entry}

\begin{entry}{%
  \Proto{make-improper-ilist-comparator}{ comparator}{procedure}{comparator}}

  The
  \texttt{make-improper-ilist-comparator} procedure returns a
  comparator that compares arbitrary objects as follows: the empty
  list precedes all ipairs, which precede all other objects. Ipairs
  are compared as if with \texttt{(make-ipair-comparator\
  }\emph{comparator}\texttt{\ }\emph{comparator}\texttt{)}.  All other
  objects are compared using \emph{comparator}.
\end{entry}

\begin{entry}{%
  \Proto{make-icar-comparator}{ comparator}{procedure}{comparator}}

  The \texttt{make-icar-comparator} procedure returns a
  comparator that compares ipairs on their icars alone using
  \emph{comparator}.
\end{entry}

\begin{entry}{%
  \Proto{make-icdr-comparator}{ comparator}{procedure}{comparator}}

  The \texttt{make-icdr-comparator} procedure returns a
  comparator that compares ipairs on their icdrs alone using
  \emph{comparator}.
\end{entry}

\subsection{{References \& links}}\label{references-links}

\begin{description}
\tightlist
\item[This document, in HTML: ]
\href{./srfi-116_files/srfi-116.html}{http://srfi.schemers.org/srfi-116/srfi-116.html}
\item[Source code for the reference implementation: ]
\url{http://srfi.schemers.org/srfi-116/ilists.tar.gz}
\item[Archive of SRFI-116 discussion-list email: ]
\url{http://srfi.schemers.org/srfi-116/mail-archive/maillist.html}
\item[SRFI web site: ]
\url{http://srfi.schemers.org/}
\end{description}

Editor:
\href{mailto:srfi-editors\%20at\%20srfi\%20dot\%20schemers\%20dot\%20org}{Mike
Sperber}
