\section{Title}\label{title}

Character-set Library

\section{Author}\label{author}

Olin Shivers

\section{Status}\label{status}

This SRFI is currently in ``final'' status. To see an explanation of
each status that a SRFI can hold, see
\href{http://srfi.schemers.org/srfi-process.html}{here}. You can access
the discussion via \href{mail-archive/maillist.html}{the archive of the
mailing list}.

\begin{itemize}
\tightlist
\item
  Received: 1999/10/17
\item
  Draft: 1999/10/30-1999/12/30
\item
  Revised: 2000/04/30
\item
  Revised: 2000/04/30
\item
  Revised: 2000/06/09
\item
  Revised: 2000/12/23
\end{itemize}

\section{Table of contents}\label{table-of-contents}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{Abstract}{Abstract}
\item
  \protect\hyperlink{VariableIndex}{Variable index}
\item
  \protect\hyperlink{Rationale}{Rationale}

  \begin{itemize}
  \tightlist
  \item
    \protect\hyperlink{LinearUpdateOperations}{``Linear-update''
    operations}
  \item
    \protect\hyperlink{ExtraSRFI}{Extra-SRFI recommendations}
  \end{itemize}
\item
  \protect\hyperlink{Specification}{Specification}

  \begin{itemize}
  \tightlist
  \item
    \protect\hyperlink{GeneralProcs}{General procedures}
  \item
    \protect\hyperlink{Iterating}{Iterating over character sets}
  \item
    \protect\hyperlink{Creating}{Creating character sets}
  \item
    \protect\hyperlink{Querying}{Querying character sets}
  \item
    \protect\hyperlink{Algebra}{Character set algebra}
  \item
    \protect\hyperlink{StandardCharsets}{Standard character sets}
  \end{itemize}
\item
  \protect\hyperlink{StandardCharsetDefs}{Unicode, Latin-1 and ASCII
  definitions of the standard character sets}
\item
  \protect\hyperlink{ReferenceImp}{Reference implementation}
\item
  \protect\hyperlink{Acknowledgements}{Acknowledgements}
\item
  \protect\hyperlink{Links}{References \& Links}
\item
  \protect\hyperlink{Copyright}{Copyright}
\end{itemize}

\section{\texorpdfstring{\href{}{Abstract}}{Abstract}}\label{abstract}

The ability to efficiently represent and manipulate sets of characters
is an unglamorous but very useful capability for text-processing code --
one that tends to pop up in the definitions of other libraries. Hence it
is useful to specify a general substrate for this functionality early.
This SRFI defines a general library that provides this functionality. It
is accompanied by a reference implementation for the spec. The reference
implementation is fairly efficient, straightforwardly portable, and has
a ``free software'' copyright. The implementation is tuned for ``small''
7 or 8 bit character types, such as ASCII or Latin-1; the data
structures and algorithms would have to be altered for larger 16 or 32
bit character types such as Unicode -- however, the specs have been
carefully designed with these larger character types in mind. Several
forthcoming SRFIs can be defined in terms of this one:

\begin{itemize}
\tightlist
\item
  string library
\item
  delimited input procedures (\emph{e.g.}, \texttt{read-line})
\item
  regular expressions
\end{itemize}

\section{\texorpdfstring{\href{}{Variable
Index}}{Variable Index}}\label{variable-index}

Here is the complete set of bindings -- procedural and otherwise --
exported by this library. In a Scheme system that has a module or
package system, these procedures should be contained in a module named
``char-set-lib''.

\begin{description}
\item[ Predicates \& comparison ]
\begin{verbatim}
char-set? char-set= char-set<= char-set-hash
\end{verbatim}
\item[ Iterating over character sets ]
\begin{verbatim}
char-set-cursor char-set-ref char-set-cursor-next end-of-char-set? 
char-set-fold char-set-unfold char-set-unfold!
char-set-for-each char-set-map
\end{verbatim}
\item[ Creating character sets ]
\begin{verbatim}
char-set-copy char-set

list->char-set  string->char-set
list->char-set! string->char-set!
    
char-set-filter  ucs-range->char-set 
char-set-filter! ucs-range->char-set!

->char-set
\end{verbatim}
\item[ Querying character sets ]
\begin{verbatim}
char-set->list char-set->string
char-set-size char-set-count char-set-contains?
char-set-every char-set-any
\end{verbatim}
\item[ Character-set algebra ]
\begin{verbatim}
char-set-adjoin  char-set-delete
char-set-adjoin! char-set-delete!

char-set-complement  char-set-union  char-set-intersection
char-set-complement! char-set-union! char-set-intersection!

char-set-difference  char-set-xor  char-set-diff+intersection
char-set-difference! char-set-xor! char-set-diff+intersection!
\end{verbatim}
\item[ Standard character sets ]
\begin{verbatim}
char-set:lower-case  char-set:upper-case  char-set:title-case
char-set:letter      char-set:digit       char-set:letter+digit
char-set:graphic     char-set:printing    char-set:whitespace
char-set:iso-control char-set:punctuation char-set:symbol
char-set:hex-digit   char-set:blank       char-set:ascii
char-set:empty       char-set:full
\end{verbatim}
\end{description}

\section{\texorpdfstring{\href{}{Rationale}}{Rationale}}\label{rationale}

The ability to efficiently manipulate sets of characters is quite useful
for text-processing code. Encapsulating this functionality in a general,
efficiently implemented library can assist all such code. This library
defines a new data structure to represent these sets, called a
``char-set.'' The char-set type is distinct from all other types.

This library is designed to be portable across implementations that use
different character types and representations, especially ASCII, Latin-1
and Unicode. Some effort has been made to preserve compatibility with
Java in the Unicode case (see the definition of
\texttt{char-set:whitespace} for the single real deviation).

\subsection{\texorpdfstring{\href{}{Linear-update
operations}}{Linear-update operations}}\label{linear-update-operations}

The procedures of this SRFI, by default, are ``pure functional'' -- they
do not alter their parameters. However, this SRFI defines a set of
``linear-update'' procedures which have a hybrid
pure-functional/side-effecting semantics: they are allowed, but not
required, to side-effect one of their parameters in order to construct
their result. An implementation may legally implement these procedures
as pure, side-effect-free functions, or it may implement them using side
effects, depending upon the details of what is the most efficient or
simple to implement in terms of the underlying representation.

The linear-update routines all have names ending with ``!''.

Clients of these procedures \emph{may not} rely upon these procedures
working by side effect. For example, this is not guaranteed to work:

\begin{verbatim}
(let* ((cs1 (char-set #\a #\b #\c))      ; cs1 = {a,b,c}.
       (cs2 (char-set-adjoin! cs1 #\d))) ; Add d to {a,b,c}.
  cs1) ; Could be either {a,b,c} or {a,b,c,d}.
\end{verbatim}

However, this is well-defined:

\begin{verbatim}
(let ((cs (char-set #\a #\b #\c)))
  (char-set-adjoin! cs #\d)) ; Add d to {a,b,c}.
\end{verbatim}

So clients of these procedures write in a functional style, but must
additionally be sure that, when the procedure is called, there are no
other live pointers to the potentially-modified character set (hence the
term ``linear update'').

There are two benefits to this convention:

\begin{itemize}
\tightlist
\item
  Implementations are free to provide the most efficient possible
  implementation, either functional or side-effecting.
\item
  Programmers may nonetheless continue to assume that character sets are
  purely functional data structures: they may be reliably shared without
  needing to be copied, uniquified, and so forth.
\end{itemize}

Note that pure functional representations are the right thing for ASCII-
or Latin-1-based Scheme implementations, since a char-set can be
represented in an ASCII Scheme with 4 32-bit words. Pure set-algebra
operations on such a representation are very fast and efficient.
Programmers who code using linear-update operations are guaranteed the
system will provide the best implementation across multiple platforms.

In practice, these procedures are most useful for efficiently
constructing character sets in a side-effecting manner, in some limited
local context, before passing the character set outside the local
construction scope to be used in a functional manner.

Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions ---
there's no linear type checker or run-time mechanism for detecting
violations. (But sophisticated programming environments, such as
DrScheme, might help.)

\subsection{\texorpdfstring{\href{}{Extra-SRFI
recommendations}}{Extra-SRFI recommendations}}\label{extra-srfi-recommendations}

Users are cautioned that the R5RS predicates

\texttt{\ char-alphabetic?\ \ char-numeric?\ \ char-whitespace?\ \ char-upper-case?\ \ char-lower-case?\ }

may or may not be in agreement with the SRFI 14 base character sets

\texttt{\ char-set:letter\ char-set:digit\ char-set:whitespace\ char-set:upper-case\ char-set:lower-case}

Implementors are strongly encouraged to bring these predicates into
agreement with the base character sets of this SRFI; not to do so risks
major confusion.

\section{\texorpdfstring{\href{}{Specification}}{Specification}}\label{specification}

In the following procedure specifications:

\begin{itemize}
\tightlist
\item
  A cs parameter is a character set.
\item
  An s parameter is a string.
\item
  A char parameter is a character.
\item
  A char-list parameter is a list of characters.
\item
  A pred parameter is a unary character predicate procedure, returning a
  true/false value when applied to a character.
\item
  An obj parameter may be any value at all.
\end{itemize}

Passing values to procedures with these parameters that do not satisfy
these types is an error.

Unless otherwise noted in the specification of a procedure, procedures
always return character sets that are distinct (from the point of view
of the linear-update operations) from the parameter character sets. For
example, \texttt{char-set-adjoin} is guaranteed to provide a fresh
character set, even if it is not given any character parameters.

Parameters given in square brackets are optional. Unless otherwise noted
in the text describing the procedure, any prefix of these optional
parameters may be supplied, from zero arguments to the full list. When a
procedure returns multiple values, this is shown by listing the return
values in square brackets, as well. So, for example, the procedure with
signature

\begin{verbatim}
halts? f [x init-store] -> [boolean integer]
\end{verbatim}

would take one (f), two (f, x) or three (f, x, init-store) input
parameters, and return two values, a boolean and an integer.

A parameter followed by "\texttt{...}" means zero-or-more elements. So
the procedure with the signature

\begin{verbatim}
sum-squares x ...  -> number
\end{verbatim}

takes zero or more arguments (x \ldots{}), while the procedure with
signature

\begin{verbatim}
spell-check doc dict1 dict2 ... -> string-list
\end{verbatim}

takes two required parameters (doc and dict\textsubscript{1}) and zero
or more optional parameters (dict\textsubscript{2} \ldots{}).

\subsection{\texorpdfstring{\href{}{General
procedures}}{General procedures}}\label{general-procedures}

\begin{description}
\item[ \href{}{} \texttt{char-set?} obj -\textgreater{} boolean ]
Is the object obj a character set?
\item[ \href{}{} \texttt{char-set=} cs\textsubscript{1} \ldots{}
-\textgreater{} boolean ]
Are the character sets equal?

Boundary cases:

\begin{verbatim}
(char-set=) => true
(char-set= cs) => true
\end{verbatim}

Rationale: transitive binary relations are generally extended to n-ary
relations in Scheme, which enables clearer, more concise code to be
written. While the zero-argument and one-argument cases will almost
certainly not arise in first-order uses of such relations, they may well
arise in higher-order cases or macro-generated code. \emph{E.g.,}
consider

\begin{verbatim}
(apply char-set= cset-list)
\end{verbatim}

This is well-defined if the list is empty or a singleton list. Hence we
extend these relations to any number of arguments. Implementors have
reported actual uses of n-ary relations in higher-order cases allowing
for fewer than two arguments. The way of Scheme is to handle the general
case; we provide the fully general extension.

A counter-argument to this extension is that
\protect\hyperlink{R5RS}{R5RS}'s transitive binary arithmetic relations
(\texttt{=}, \texttt{\textless{}}, \emph{etc.}) require at least two
arguments, hence this decision is a break with the prior convention --
although it is at least one that is backwards-compatible.
\item[ \href{}{} \texttt{char-set\textless{}=} cs\textsubscript{1}
\ldots{} -\textgreater{} boolean ]
Returns true if every character set cs\textsubscript{i} is a subset of
character set cs\textsubscript{i+1}.

Boundary cases:

\begin{verbatim}
(char-set<=) => true
(char-set<= cs) => true
\end{verbatim}

Rationale: See \texttt{char-set=} for discussion of zero- and
one-argument applications. Consider testing a list of char-sets for
monotonicity with

\begin{verbatim}
(apply char-set<= cset-list)
\end{verbatim}
\item[ \href{}{} \texttt{char-set-hash} cs {[}bound{]} -\textgreater{}
integer ]
Compute a hash value for the character set cs. Bound is a non-negative
exact integer specifying the range of the hash function. A positive
value restricts the return value to the range {[}0,bound).

If bound is either zero or not given, the implementation may use an
implementation-specific default value, chosen to be as large as is
efficiently practical. For instance, the default range might be chosen
for a given implementation to map all strings into the range of integers
that can be represented with a single machine word.

Invariant:

\begin{verbatim}
(char-set= cs1 cs2) => (= (char-set-hash cs1 b) (char-set-hash cs2 b))
\end{verbatim}

A legal but nonetheless discouraged implementation:

\begin{verbatim}
(define (char-set-hash cs . maybe-bound) 1)
\end{verbatim}

Rationale: allowing the user to specify an explicit bound simplifies
user code by removing the mod operation that typically accompanies every
hash computation, and also may allow the implementation of the hash
function to exploit a reduced range to efficiently compute the hash
value. \emph{E.g.}, for small bounds, the hash function may be computed
in a fashion such that intermediate values never overflow into bignum
integers, allowing the implementor to provide a fixnum-specific ``fast
path'' for computing the common cases very rapidly.
\end{description}

\subsection{\texorpdfstring{\href{}{Iterating over character
sets}}{Iterating over character sets}}\label{iterating-over-character-sets}

\begin{description}
\item[ \href{}{} \href{}{} \href{}{} \href{}{} \texttt{char-set-cursor}
cset -\textgreater{} cursor\\
\texttt{char-set-ref} cset cursor -\textgreater{} char\\
\texttt{char-set-cursor-next} cset cursor -\textgreater{} cursor\\
\texttt{end-of-char-set?} cursor -\textgreater{} boolean ]
Cursors are a low-level facility for iterating over the characters in a
set. A cursor is a value that indexes a character in a char set.
\texttt{char-set-cursor} produces a new cursor for a given char set. The
set element indexed by the cursor is fetched with \texttt{char-set-ref}.
A cursor index is incremented with \texttt{char-set-cursor-next}; in
this way, code can step through every character in a char set. Stepping
a cursor ``past the end'' of a char set produces a cursor that answers
true to \texttt{end-of-char-set?}. It is an error to pass such a cursor
to \texttt{char-set-ref} or to \texttt{char-set-cursor-next}.

A cursor value may not be used in conjunction with a different character
set; if it is passed to \texttt{char-set-ref} or
\texttt{char-set-cursor-next} with a character set other than the one
used to create it, the results and effects are undefined.

Cursor values are \emph{not} necessarily distinct from other types. They
may be integers, linked lists, records, procedures or other values. This
license is granted to allow cursors to be very ``lightweight'' values
suitable for tight iteration, even in fairly simple implementations.

Note that these primitives are necessary to export an iteration facility
for char sets to loop macros.

Example:

\begin{verbatim}
(define cs (char-set #\G #\a #\T #\e #\c #\h))

;; Collect elts of CS into a list.
(let lp ((cur (char-set-cursor cs)) (ans '()))
  (if (end-of-char-set? cur) ans
      (lp (char-set-cursor-next cs cur)
          (cons (char-set-ref cs cur) ans))))
  => (#\G #\T #\a #\c #\e #\h)

;; Equivalently, using a list unfold (from SRFI 1):
(unfold-right end-of-char-set? 
              (curry char-set-ref cs)
          (curry char-set-cursor-next cs)
          (char-set-cursor cs))
  => (#\G #\T #\a #\c #\e #\h)
\end{verbatim}

Rationale: Note that the cursor API's four functions ``fit'' the
functional protocol used by the unfolders provided by the list, string
and char-set SRFIs (see the example above). By way of contrast, here is
a simpler, two-function API that was rejected for failing this
criterion. Besides \texttt{char-set-cursor}, it provided a single
function that mapped a cursor and a character set to two values, the
indexed character and the next cursor. If the cursor had exhausted the
character set, then this function returned false instead of the
character value, and another end-of-char-set cursor. In this way, the
other three functions of the current API were combined together.
\item[ \href{}{} \texttt{char-set-fold} kons knil cs -\textgreater{}
object ]
This is the fundamental iterator for character sets. Applies the
function kons across the character set cs using initial state value
knil. That is, if cs is the empty set, the procedure returns knil.
Otherwise, some element c of cs is chosen; let cs' be the remaining,
unchosen characters. The procedure returns

\begin{verbatim}
(char-set-fold kons (kons c knil) cs')
\end{verbatim}

Examples:

\begin{verbatim}
;; CHAR-SET-MEMBERS
(lambda (cs) (char-set-fold cons '() cs))

;; CHAR-SET-SIZE
(lambda (cs) (char-set-fold (lambda (c i) (+ i 1)) 0 cs))

;; How many vowels in the char set?
(lambda (cs) 
  (char-set-fold (lambda (c i) (if (vowel? c) (+ i 1) i))
                 0 cs))
\end{verbatim}
\item[ \href{}{} \href{}{} \texttt{char-set-unfold~} f p g seed
{[}base-cs{]} -\textgreater{} char-set\\
\texttt{char-set-unfold!} f p g seed base-cs -\textgreater{} char-set ]
This is a fundamental constructor for char-sets.

\begin{itemize}
\tightlist
\item
  G is used to generate a series of ``seed'' values from the initial
  seed: seed, (g seed), (g\textsuperscript{2} seed),
  (g\textsuperscript{3} seed), \ldots{}
\item
  P tells us when to stop -- when it returns true when applied to one of
  these seed values.
\item
  F maps each seed value to a character. These characters are added to
  the base character set base-cs to form the result; base-cs defaults to
  the empty set. \texttt{char-set-unfold!} adds the characters to
  base-cs in a linear-update -- it is allowed, but not required, to
  side-effect and use base-cs's storage to construct the result.
\end{itemize}

More precisely, the following definitions hold, ignoring the
optional-argument issues:

\begin{verbatim}
(define (char-set-unfold p f g seed base-cs) 
  (char-set-unfold! p f g seed (char-set-copy base-cs)))

(define (char-set-unfold! p f g seed base-cs)
  (let lp ((seed seed) (cs base-cs))
        (if (p seed) cs                                 ; P says we are done.
            (lp (g seed)                                ; Loop on (G SEED).
                (char-set-adjoin! cs (f seed))))))      ; Add (F SEED) to set.
\end{verbatim}

(Note that the actual implementation may be more efficient.)

Examples:

\begin{verbatim}
                         
(port->char-set p) = (char-set-unfold eof-object? values
                                      (lambda (x) (read-char p))
                                      (read-char p))

(list->char-set lis) = (char-set-unfold null? car cdr lis)
\end{verbatim}
\item[ \href{}{} \texttt{char-set-for-each} proc cs -\textgreater{}
unspecified ]
Apply procedure proc to each character in the character set cs. Note
that the order in which proc is applied to the characters in the set is
not specified, and may even change from one procedure application to
another.

Nothing at all is specified about the value returned by this procedure;
it is not even required to be consistent from call to call. It is simply
required to be a value (or values) that may be passed to a command
continuation, \emph{e.g.} as the value of an expression appearing as a
non-terminal subform of a \texttt{begin} expression. Note that in
\protect\hyperlink{R5RS}{R5RS}, this restricts the procedure to
returning a single value; non-R5RS systems may not even provide this
restriction.
\item[ \href{}{} \texttt{char-set-map} proc cs -\textgreater{} char-set
]
proc is a char-\textgreater{}char procedure. Apply it to all the
characters in the char-set cs, and collect the results into a new
character set.

Essentially lifts proc from a char-\textgreater{}char procedure to a
char-set -\textgreater{} char-set procedure.

Example:

\begin{verbatim}
(char-set-map char-downcase cset)
\end{verbatim}
\end{description}

\subsection{\texorpdfstring{\href{}{Creating character
sets}}{Creating character sets}}\label{creating-character-sets}

\begin{description}
\item[ \href{}{} \texttt{char-set-copy} cs -\textgreater{} char-set ]
Returns a copy of the character set cs. ``Copy'' means that if either
the input parameter or the result value of this procedure is passed to
one of the linear-update procedures described below, the other character
set is guaranteed not to be altered.

A system that provides pure-functional implementations of the
linear-operator suite could implement this procedure as the identity
function -- so copies are \emph{not} guaranteed to be distinct by
\texttt{eq?}.
\item[ \href{}{} \texttt{char-set} char\textsubscript{1} \ldots{}
-\textgreater{} char-set ]
Return a character set containing the given characters.
\item[ \href{}{} \href{}{} \texttt{list-\textgreater{}char-set~}
char-list {[}base-cs{]} -\textgreater{} char-set\\
\texttt{list-\textgreater{}char-set!} char-list base-cs -\textgreater{}
char-set ]
Return a character set containing the characters in the list of
characters char-list.

If character set base-cs is provided, the characters from char-list are
added to it. \texttt{list-\textgreater{}char-set!} is allowed, but not
required, to side-effect and reuse the storage in base-cs;
\texttt{list-\textgreater{}char-set} produces a fresh character set.
\item[ \href{}{} \href{}{} \texttt{string-\textgreater{}char-set~} s
{[}base-cs{]} -\textgreater{} char-set\\
\texttt{string-\textgreater{}char-set!} s base-cs -\textgreater{}
char-set ]
Return a character set containing the characters in the string s.

If character set base-cs is provided, the characters from s are added to
it. \texttt{string-\textgreater{}char-set!} is allowed, but not
required, to side-effect and reuse the storage in base-cs;
\texttt{string-\textgreater{}char-set} produces a fresh character set.
\item[ \href{}{} \href{}{} \texttt{char-set-filter~} pred cs
{[}base-cs{]} -\textgreater{} char-set\\
\texttt{char-set-filter!} pred cs base-cs -\textgreater{} char-set ]
Returns a character set containing every character c in cs such that
\texttt{(pred\ c)} returns true.

If character set base-cs is provided, the characters specified by pred
are added to it. \texttt{char-set-filter!} is allowed, but not required,
to side-effect and reuse the storage in base-cs;
\texttt{char-set-filter} produces a fresh character set.

An implementation may not save away a reference to pred and invoke it
after \texttt{char-set-filter} or \texttt{char-set-filter!} returns --
that is, ``lazy,'' on-demand implementations are not allowed, as pred
may have external dependencies on mutable data or have other
side-effects.

Rationale: This procedure provides a means of converting a character
predicate into its equivalent character set; the cs parameter allows the
programmer to bound the predicate's domain. Programmers should be aware
that filtering a character set such as \texttt{char-set:full} could be a
very expensive operation in an implementation that provided an extremely
large character type, such as 32-bit Unicode. An earlier draft of this
library provided a simple \texttt{predicate-\textgreater{}char-set}
procedure, which was rejected in favor of \texttt{char-set-filter} for
this reason.
\item[ \href{}{} \href{}{} \texttt{ucs-range-\textgreater{}char-set~}
lower upper {[}error? base-cs{]} -\textgreater{} char-set\\
\texttt{ucs-range-\textgreater{}char-set!} lower upper error? base-cs
-\textgreater{} char-set ]
Lower and upper are exact non-negative integers; lower \textless{}=
upper.

Returns a character set containing every character whose ISO/IEC 10646
UCS-4 code lies in the half-open range {[}lower,upper).

\begin{itemize}
\tightlist
\item
  If the requested range includes unassigned UCS values, these are
  silently ignored (the current UCS specification has ``holes'' in the
  space of assigned codes).
\item
  If the requested range includes ``private'' or ``user space'' codes,
  these are handled in an implementation-specific manner; however, a
  UCS- or Unicode-based Scheme implementation should pass them through
  transparently.
\item
  If any code from the requested range specifies a valid, assigned UCS
  character that has no corresponding representative in the
  implementation's character type, then (1) an error is raised if error?
  is true, and (2) the code is ignored if error? is false (the default).
  This might happen, for example, if the implementation uses ASCII
  characters, and the requested range includes non-ASCII characters.
\end{itemize}

If character set base-cs is provided, the characters specified by the
range are added to it. \texttt{ucs-range-\textgreater{}char-set!} is
allowed, but not required, to side-effect and reuse the storage in
base-cs; \texttt{ucs-range-\textgreater{}char-set} produces a fresh
character set.

Note that ASCII codes are a subset of the Latin-1 codes, which are in
turn a subset of the 16-bit Unicode codes, which are themselves a subset
of the 32-bit UCS-4 codes. We commit to a specific encoding in this
routine, regardless of the underlying representation of characters, so
that client code using this library will be portable. \emph{I.e.}, a
conformant Scheme implementation may use EBCDIC or SHIFT-JIS to encode
characters; it must simply map the UCS characters from the given range
into the native representation when possible, and report errors when not
possible.
\item[ \href{}{} \texttt{-\textgreater{}char-set} x -\textgreater{}
char-set ]
Coerces x into a char-set. X may be a string, character or char-set. A
string is converted to the set of its constituent characters; a
character is converted to a singleton set; a char-set is returned as-is.
This procedure is intended for use by other procedures that want to
provide ``user-friendly,'' wide-spectrum interfaces to their clients.
\end{description}

\subsection{\texorpdfstring{\href{}{Querying character
sets}}{Querying character sets}}\label{querying-character-sets}

\begin{description}
\item[ \href{}{} \texttt{char-set-size} cs -\textgreater{} integer ]
Returns the number of elements in character set cs.
\item[ \href{}{} \texttt{char-set-count} pred cs -\textgreater{} integer
]
Apply pred to the chars of character set cs, and return the number of
chars that caused the predicate to return true.
\item[ \href{}{} \texttt{char-set-\textgreater{}list} cs -\textgreater{}
character-list ]
This procedure returns a list of the members of character set cs. The
order in which cs's characters appear in the list is not defined, and
may be different from one call to another.
\item[ \href{}{} \texttt{char-set-\textgreater{}string} cs
-\textgreater{} string ]
This procedure returns a string containing the members of character set
cs. The order in which cs's characters appear in the string is not
defined, and may be different from one call to another.
\item[ \href{}{} \texttt{char-set-contains?} cs char -\textgreater{}
boolean ]
This procedure tests char for membership in character set cs.

The MIT Scheme character-set package called this procedure
char-set-member?, but the argument order isn't consistent with the name.
\item[ \href{}{} \href{}{} \texttt{char-set-every} pred cs
-\textgreater{} boolean\\
\texttt{char-set-any~~} pred cs -\textgreater{} boolean ]
The \texttt{char-set-every} procedure returns true if predicate pred
returns true of every character in the character set cs. Likewise,
\texttt{char-set-any} applies pred to every character in character set
cs, and returns the first true value it finds. If no character produces
a true value, it returns false. The order in which these procedures
sequence through the elements of cs is not specified.

Note that if you need to determine the actual character on which a
predicate returns true, use \texttt{char-set-any} and arrange for the
predicate to return the character parameter as its true value,
\emph{e.g.}

\begin{verbatim}
(char-set-any (lambda (c) (and (char-upper-case? c) c)) 
              cs)
\end{verbatim}
\end{description}

\subsection{\texorpdfstring{\href{}{Character-set
algebra}}{Character-set algebra}}\label{character-set-algebra}

\begin{description}
\item[ \href{}{} \href{}{} \texttt{char-set-adjoin} cs
char\textsubscript{1} \ldots{} -\textgreater{} char-set\\
\texttt{char-set-delete} cs char\textsubscript{1} \ldots{}
-\textgreater{} char-set ]
Add/delete the char\textsubscript{i} characters to/from character set
cs.
\item[ \href{}{} \href{}{} \texttt{char-set-adjoin!} cs
char\textsubscript{1} \ldots{} -\textgreater{} char-set\\
\texttt{char-set-delete!} cs char\textsubscript{1} \ldots{}
-\textgreater{} char-set ]
Linear-update variants. These procedures are allowed, but not required,
to side-effect their first parameter.
\item[ \href{}{} \href{}{} \href{}{} \href{}{} \href{}{} \href{}{}
\texttt{char-set-complement} cs -\textgreater{} char-set\\
\texttt{char-set-union} cs\textsubscript{1} \ldots{} -\textgreater{}
char-set\\
\texttt{char-set-intersection} cs\textsubscript{1} \ldots{}
-\textgreater{} char-set\\
\texttt{char-set-difference} cs\textsubscript{1} cs\textsubscript{2}
\ldots{} -\textgreater{} char-set\\
\texttt{char-set-xor} cs\textsubscript{1} \ldots{} -\textgreater{}
char-set\\
\texttt{char-set-diff+intersection} cs\textsubscript{1}
cs\textsubscript{2} \ldots{} -\textgreater{} {[}char-set char-set{]} ]
These procedures implement set complement, union, intersection,
difference, and exclusive-or for character sets. The union, intersection
and xor operations are n-ary. The difference function is also n-ary,
associates to the left (that is, it computes the difference between its
first argument and the union of all the other arguments), and requires
at least one argument.

Boundary cases:

\begin{verbatim}
(char-set-union) => char-set:empty
(char-set-intersection) => char-set:full
(char-set-xor) => char-set:empty
(char-set-difference cs) => cs
\end{verbatim}

\texttt{char-set-diff+intersection} returns both the difference and the
intersection of the arguments -- it partitions its first parameter. It
is equivalent to

\begin{verbatim}
(values (char-set-difference cs1 cs2 ...)
        (char-set-intersection cs1 (char-set-union cs2 ...)))
\end{verbatim}

but can be implemented more efficiently.

Programmers should be aware that \texttt{char-set-complement} could
potentially be a very expensive operation in Scheme implementations that
provide a very large character type, such as 32-bit Unicode. If this is
a possibility, sets can be complimented with respect to a smaller
universe using \texttt{char-set-difference}.
\item[ \href{}{} \href{}{} \href{}{} \href{}{} \href{}{} \href{}{}
\texttt{char-set-complement!} cs -\textgreater{} char-set\\
\texttt{char-set-union!} cs\textsubscript{1} cs\textsubscript{2}
\ldots{} -\textgreater{} char-set\\
\texttt{char-set-intersection!} cs\textsubscript{1} cs\textsubscript{2}
\ldots{} -\textgreater{} char-set\\
\texttt{char-set-difference!} cs\textsubscript{1} cs\textsubscript{2}
\ldots{} -\textgreater{} char-set\\
\texttt{char-set-xor!} cs\textsubscript{1} cs\textsubscript{2} \ldots{}
-\textgreater{} char-set\\
\texttt{char-set-diff+intersection!} cs\textsubscript{1}
cs\textsubscript{2} cs\textsubscript{3} \ldots{} -\textgreater{}
{[}char-set char-set{]} ]
These are linear-update variants of the set-algebra functions. They are
allowed, but not required, to side-effect their first (required)
parameter.

\texttt{char-set-diff+intersection!} is allowed to side-effect both of
its two required parameters, cs\textsubscript{1} and
cs\textsubscript{2}.
\end{description}

\subsection{\texorpdfstring{\href{}{Standard character
sets}}{Standard character sets}}\label{standard-character-sets}

Several character sets are predefined for convenience: \href{}{}
\href{}{} \href{}{} \href{}{} \href{}{} \href{}{} \href{}{} \href{}{}
\href{}{} \href{}{} \href{}{} \href{}{} \href{}{} \href{}{} \href{}{}
\href{}{} \href{}{} \href{}{}

\begin{longtable}[]{@{}ll@{}}
\toprule
\texttt{char-set:lower-case} & Lower-case letters\tabularnewline
\texttt{char-set:upper-case} & Upper-case letters\tabularnewline
\texttt{char-set:title-case} & Title-case letters\tabularnewline
\texttt{char-set:letter} & Letters\tabularnewline
\texttt{char-set:digit} & Digits\tabularnewline
\texttt{char-set:letter+digit} & Letters and digits\tabularnewline
\texttt{char-set:graphic} & Printing characters except
spaces\tabularnewline
\texttt{char-set:printing} & Printing characters including
spaces\tabularnewline
\texttt{char-set:whitespace} & Whitespace characters\tabularnewline
\texttt{char-set:iso-control} & The ISO control
characters\tabularnewline
\texttt{char-set:punctuation} & Punctuation characters\tabularnewline
\texttt{char-set:symbol} & Symbol characters\tabularnewline
\texttt{char-set:hex-digit} & A hexadecimal digit: 0-9, A-F,
a-f\tabularnewline
\texttt{char-set:blank} & Blank characters -- horizontal
whitespace\tabularnewline
\texttt{char-set:ascii} & All characters in the ASCII
set.\tabularnewline
\texttt{char-set:empty} & Empty set\tabularnewline
\texttt{char-set:full} & All characters\tabularnewline
\bottomrule
\end{longtable}

Note that there may be characters in \texttt{char-set:letter} that are
neither upper or lower case---this might occur in implementations that
use a character type richer than ASCII, such as Unicode. A ``graphic
character'' is one that would put ink on your page. While the exact
composition of these sets may vary depending upon the character type
provided by the underlying Scheme system, here are the definitions for
some of the sets in an ASCII implementation:

\begin{longtable}[]{@{}ll@{}}
\toprule
\texttt{char-set:lower-case} & a-z\tabularnewline
\texttt{char-set:upper-case} & A-Z\tabularnewline
\texttt{char-set:letter} & A-Z and a-z\tabularnewline
\texttt{char-set:digit} & 0123456789\tabularnewline
\texttt{char-set:punctuation} &
\texttt{!"\#\%\&\textquotesingle{}()*,-./:;?@{[}\textbackslash{}{]}\_\{\}}\tabularnewline
\texttt{char-set:symbol} &
\texttt{\$+\textless{}=\textgreater{}\^{}`\textbar{}\textasciitilde{}}\tabularnewline
\texttt{char-set:whitespace} & Space, newline, tab, form
feed,\tabularnewline
& vertical tab, carriage return\tabularnewline
\texttt{char-set:blank} & Space and tab\tabularnewline
\texttt{char-set:graphic} & letter + digit + punctuation +
symbol\tabularnewline
\texttt{char-set:printing} & graphic + whitespace\tabularnewline
\texttt{char-set:iso-control} & ASCII 0-31 and 127\tabularnewline
\bottomrule
\end{longtable}

Note that the existence of the \texttt{char-set:ascii} set implies that
the underlying character set is required to be at least as rich as ASCII
(including ASCII's control characters).

Rationale: The name choices reflect a shift from the older
``alphabetic/numeric'' terms found in \protect\hyperlink{R5RS}{R5RS} and
Posix to newer, Unicode-influenced ``letter/digit'' lexemes.

\section{\texorpdfstring{\href{}{Unicode, Latin-1 and ASCII definitions
of the standard character
sets}}{Unicode, Latin-1 and ASCII definitions of the standard character sets}}\label{unicode-latin-1-and-ascii-definitions-of-the-standard-character-sets}

In Unicode Scheme implementations, the base character sets are
compatible with Java's Unicode specifications. For ASCII or Latin-1, we
simply restrict the Unicode set specifications to their first 128 or 256
codes, respectively. Scheme implementations that are not based on ASCII,
Latin-1 or Unicode should attempt to preserve the sense or spirit of
these definitions.

The following descriptions frequently make reference to the ``Unicode
character database.'' This is a file, available at URL

\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

Each line contains a description of a Unicode character. The first
semicolon-delimited field of the line gives the hex value of the
character's code; the second field gives the name of the character, and
the third field gives a two-letter category. Other fields give simple
1-1 case-mappings for the character and other information; see

\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}

for further description of the file's format. Note in particular the
two-letter category specified in the the third field, which is
referenced frequently in the descriptions below.

\subsection{\texorpdfstring{\href{}{char-set:lower-case}}{char-set:lower-case}}\label{char-setlower-case}

For Unicode, we follow Java's specification: a character is lowercase if

\begin{itemize}
\tightlist
\item
  it is not in the range {[}U+2000,U+2FFF{]}, and
\item
  the Unicode attribute table does not give a lowercase mapping for it,
  and
\item
  at least one of the following is true:

  \begin{itemize}
  \tightlist
  \item
    the Unicode attribute table gives a mapping to uppercase for the
    character, or
  \item
    the name for the character in the Unicode attribute table contains
    the words ``SMALL LETTER'' or ``SMALL LIGATURE''.
  \end{itemize}
\end{itemize}

The lower-case ASCII characters are

abcdefghijklmnopqrstuvwxyz

Latin-1 adds another 33 lower-case characters to the ASCII set:

\begin{longtable}[]{@{}ll@{}}
\toprule
00B5 & MICRO SIGN\tabularnewline
00DF & LATIN SMALL LETTER SHARP S\tabularnewline
00E0 & LATIN SMALL LETTER A WITH GRAVE\tabularnewline
00E1 & LATIN SMALL LETTER A WITH ACUTE\tabularnewline
00E2 & LATIN SMALL LETTER A WITH CIRCUMFLEX\tabularnewline
00E3 & LATIN SMALL LETTER A WITH TILDE\tabularnewline
00E4 & LATIN SMALL LETTER A WITH DIAERESIS\tabularnewline
00E5 & LATIN SMALL LETTER A WITH RING ABOVE\tabularnewline
00E6 & LATIN SMALL LETTER AE\tabularnewline
00E7 & LATIN SMALL LETTER C WITH CEDILLA\tabularnewline
00E8 & LATIN SMALL LETTER E WITH GRAVE\tabularnewline
00E9 & LATIN SMALL LETTER E WITH ACUTE\tabularnewline
00EA & LATIN SMALL LETTER E WITH CIRCUMFLEX\tabularnewline
00EB & LATIN SMALL LETTER E WITH DIAERESIS\tabularnewline
00EC & LATIN SMALL LETTER I WITH GRAVE\tabularnewline
00ED & LATIN SMALL LETTER I WITH ACUTE\tabularnewline
00EE & LATIN SMALL LETTER I WITH CIRCUMFLEX\tabularnewline
00EF & LATIN SMALL LETTER I WITH DIAERESIS\tabularnewline
00F0 & LATIN SMALL LETTER ETH\tabularnewline
00F1 & LATIN SMALL LETTER N WITH TILDE\tabularnewline
00F2 & LATIN SMALL LETTER O WITH GRAVE\tabularnewline
00F3 & LATIN SMALL LETTER O WITH ACUTE\tabularnewline
00F4 & LATIN SMALL LETTER O WITH CIRCUMFLEX\tabularnewline
00F5 & LATIN SMALL LETTER O WITH TILDE\tabularnewline
00F6 & LATIN SMALL LETTER O WITH DIAERESIS\tabularnewline
00F8 & LATIN SMALL LETTER O WITH STROKE\tabularnewline
00F9 & LATIN SMALL LETTER U WITH GRAVE\tabularnewline
00FA & LATIN SMALL LETTER U WITH ACUTE\tabularnewline
00FB & LATIN SMALL LETTER U WITH CIRCUMFLEX\tabularnewline
00FC & LATIN SMALL LETTER U WITH DIAERESIS\tabularnewline
00FD & LATIN SMALL LETTER Y WITH ACUTE\tabularnewline
00FE & LATIN SMALL LETTER THORN\tabularnewline
00FF & LATIN SMALL LETTER Y WITH DIAERESIS\tabularnewline
\bottomrule
\end{longtable}

Note that three of these have no corresponding Latin-1 upper-case
character:

\begin{longtable}[]{@{}ll@{}}
\toprule
00B5 & MICRO SIGN\tabularnewline
00DF & LATIN SMALL LETTER SHARP S\tabularnewline
00FF & LATIN SMALL LETTER Y WITH DIAERESIS\tabularnewline
\bottomrule
\end{longtable}

(The compatibility micro character uppercases to the non-Latin-1 Greek
capital mu; the German sharp s character uppercases to the pair of
characters ``SS,'' and the capital y-with-diaeresis is non-Latin-1.)

(Note that the Java spec for lowercase characters given at

\url{http://java.sun.com/docs/books/jls/html/javalang.doc4.html\#14345}

is inconsistent. U+00B5 MICRO SIGN fulfills the requirements for a
lower-case character (as of Unicode 3.0), but is not given in the
numeric list of lower-case character codes.)

(Note that the Java spec for \texttt{isLowerCase()} given at

\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html\#isLowerCase(char)}

gives three mutually inconsistent definitions of ``lower case.'' The
first is the definition used in this SRFI. Following text says ``A
character is considered to be lowercase if and only if it is specified
to be lowercase by the Unicode 2.0 standard (category Ll in the Unicode
specification data file).'' The former spec excludes U+00AA FEMININE
ORDINAL INDICATOR and U+00BA MASCULINE ORDINAL INDICATOR; the later spec
includes them. Finally, the spec enumerates a list of characters in the
Latin-1 subset; this list excludes U+00B5 MICRO SIGN, which is included
in both of the previous specs.)

\subsection{\texorpdfstring{\href{}{char-set:upper-case}}{char-set:upper-case}}\label{char-setupper-case}

For Unicode, we follow Java's specification: a character is uppercase if

\begin{itemize}
\tightlist
\item
  it is not in the range {[}U+2000,U+2FFF{]}, and
\item
  the Unicode attribute table does not give an uppercase mapping for it
  (this excludes titlecase characters), and
\item
  at least one of the following is true:

  \begin{itemize}
  \tightlist
  \item
    the Unicode attribute table gives a mapping to lowercase for the
    character, or
  \item
    the name for the character in the Unicode attribute table contains
    the words ``CAPITAL LETTER'' or ``CAPITAL LIGATURE''.
  \end{itemize}
\end{itemize}

The upper-case ASCII characters are

ABCDEFGHIJKLMNOPQRSTUVWXYZ

Latin-1 adds another 30 upper-case characters to the ASCII set:

\begin{longtable}[]{@{}ll@{}}
\toprule
00C0 & LATIN CAPITAL LETTER A WITH GRAVE\tabularnewline
00C1 & LATIN CAPITAL LETTER A WITH ACUTE\tabularnewline
00C2 & LATIN CAPITAL LETTER A WITH CIRCUMFLEX\tabularnewline
00C3 & LATIN CAPITAL LETTER A WITH TILDE\tabularnewline
00C4 & LATIN CAPITAL LETTER A WITH DIAERESIS\tabularnewline
00C5 & LATIN CAPITAL LETTER A WITH RING ABOVE\tabularnewline
00C6 & LATIN CAPITAL LETTER AE\tabularnewline
00C7 & LATIN CAPITAL LETTER C WITH CEDILLA\tabularnewline
00C8 & LATIN CAPITAL LETTER E WITH GRAVE\tabularnewline
00C9 & LATIN CAPITAL LETTER E WITH ACUTE\tabularnewline
00CA & LATIN CAPITAL LETTER E WITH CIRCUMFLEX\tabularnewline
00CB & LATIN CAPITAL LETTER E WITH DIAERESIS\tabularnewline
00CC & LATIN CAPITAL LETTER I WITH GRAVE\tabularnewline
00CD & LATIN CAPITAL LETTER I WITH ACUTE\tabularnewline
00CE & LATIN CAPITAL LETTER I WITH CIRCUMFLEX\tabularnewline
00CF & LATIN CAPITAL LETTER I WITH DIAERESIS\tabularnewline
00D0 & LATIN CAPITAL LETTER ETH\tabularnewline
00D1 & LATIN CAPITAL LETTER N WITH TILDE\tabularnewline
00D2 & LATIN CAPITAL LETTER O WITH GRAVE\tabularnewline
00D3 & LATIN CAPITAL LETTER O WITH ACUTE\tabularnewline
00D4 & LATIN CAPITAL LETTER O WITH CIRCUMFLEX\tabularnewline
00D5 & LATIN CAPITAL LETTER O WITH TILDE\tabularnewline
00D6 & LATIN CAPITAL LETTER O WITH DIAERESIS\tabularnewline
00D8 & LATIN CAPITAL LETTER O WITH STROKE\tabularnewline
00D9 & LATIN CAPITAL LETTER U WITH GRAVE\tabularnewline
00DA & LATIN CAPITAL LETTER U WITH ACUTE\tabularnewline
00DB & LATIN CAPITAL LETTER U WITH CIRCUMFLEX\tabularnewline
00DC & LATIN CAPITAL LETTER U WITH DIAERESIS\tabularnewline
00DD & LATIN CAPITAL LETTER Y WITH ACUTE\tabularnewline
00DE & LATIN CAPITAL LETTER THORN\tabularnewline
\bottomrule
\end{longtable}

\subsection{\texorpdfstring{\href{}{char-set:title-case}}{char-set:title-case}}\label{char-settitle-case}

In Unicode, a character is titlecase if it has the category Lt in the
character attribute database. There are very few of these characters;
here is the entire 31-character list as of Unicode 3.0:

\begin{longtable}[]{@{}ll@{}}
\toprule
01C5 & LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH
CARON\tabularnewline
01C8 & LATIN CAPITAL LETTER L WITH SMALL LETTER J\tabularnewline
01CB & LATIN CAPITAL LETTER N WITH SMALL LETTER J\tabularnewline
01F2 & LATIN CAPITAL LETTER D WITH SMALL LETTER Z\tabularnewline
1F88 & GREEK CAPITAL LETTER ALPHA WITH PSILI AND
PROSGEGRAMMENI\tabularnewline
1F89 & GREEK CAPITAL LETTER ALPHA WITH DASIA AND
PROSGEGRAMMENI\tabularnewline
1F8A & GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F8B & GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F8C & GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F8D & GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F8E & GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1F8F & GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1F98 & GREEK CAPITAL LETTER ETA WITH PSILI AND
PROSGEGRAMMENI\tabularnewline
1F99 & GREEK CAPITAL LETTER ETA WITH DASIA AND
PROSGEGRAMMENI\tabularnewline
1F9A & GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F9B & GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F9C & GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F9D & GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F9E & GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1F9F & GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1FA8 & GREEK CAPITAL LETTER OMEGA WITH PSILI AND
PROSGEGRAMMENI\tabularnewline
1FA9 & GREEK CAPITAL LETTER OMEGA WITH DASIA AND
PROSGEGRAMMENI\tabularnewline
1FAA & GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1FAB & GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1FAC & GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1FAD & GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1FAE & GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1FAF & GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1FBC & GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI\tabularnewline
1FCC & GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI\tabularnewline
1FFC & GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI\tabularnewline
\bottomrule
\end{longtable}

There are no ASCII or Latin-1 titlecase characters.

\subsection{\texorpdfstring{\href{}{char-set:letter}}{char-set:letter}}\label{char-setletter}

In Unicode, a letter is any character with one of the letter categories
(Lu, Ll, Lt, Lm, Lo) in the Unicode character database.

There are 52 ASCII letters

abcdefghijklmnopqrstuvwxyz\\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\\

There are 117 Latin-1 letters. These are the 115 characters that are
members of the Latin-1 \texttt{char-set:lower-case} and
\texttt{char-set:upper-case} sets, plus

\begin{longtable}[]{@{}ll@{}}
\toprule
00AA & FEMININE ORDINAL INDICATOR\tabularnewline
00BA & MASCULINE ORDINAL INDICATOR\tabularnewline
\bottomrule
\end{longtable}

(These two letters are considered lower-case by Unicode, but not by Java
or SRFI 14.)

\subsection{\texorpdfstring{\href{}{char-set:digit}}{char-set:digit}}\label{char-setdigit}

In Unicode, a character is a digit if it has the category Nd in the
character attribute database. In Latin-1 and ASCII, the only such
characters are 0123456789. In Unicode, there are other digit characters
in other code blocks, such as Gujarati digits and Tibetan digits.

\subsection{\texorpdfstring{\href{}{char-set:hex-digit}}{char-set:hex-digit}}\label{char-sethex-digit}

The only hex digits are 0123456789abcdefABCDEF.

\subsection{\texorpdfstring{\href{}{char-set:letter+digit}}{char-set:letter+digit}}\label{char-setletterdigit}

The union of \texttt{char-set:letter} and \texttt{char-set:digit.}

\subsection{\texorpdfstring{\href{}{char-set:graphic}}{char-set:graphic}}\label{char-setgraphic}

A graphic character is one that would put ink on paper. The ASCII and
Latin-1 graphic characters are the members of

\begin{longtable}[]{@{}l@{}}
\toprule
\texttt{char-set:letter}\tabularnewline
\texttt{char-set:digit}\tabularnewline
\texttt{char-set:punctuation}\tabularnewline
\texttt{char-set:symbol}\tabularnewline
\bottomrule
\end{longtable}

\subsection{\texorpdfstring{\href{}{char-set:printing}}{char-set:printing}}\label{char-setprinting}

A printing character is one that would occupy space when printed,
\emph{i.e.}, a graphic character or a space character.
\texttt{char-set:printing} is the union of \texttt{char-set:whitespace}
and \texttt{char-set:graphic.}

\subsection{\texorpdfstring{\href{}{char-set:whitespace}}{char-set:whitespace}}\label{char-setwhitespace}

In Unicode, a whitespace character is either

\begin{itemize}
\tightlist
\item
  a character with one of the space, line, or paragraph separator
  categories (Zs, Zl or Zp) of the Unicode character database.
\item
  U+0009 Horizontal tabulation (\textbackslash{}t control-I)
\item
  U+000A Line feed (\textbackslash{}n control-J)
\item
  U+000B Vertical tabulation (\textbackslash{}v control-K)
\item
  U+000C Form feed (\textbackslash{}f control-L)
\item
  U+000D Carriage return (\textbackslash{}r control-M)
\end{itemize}

There are 24 whitespace characters in Unicode 3.0:

\begin{longtable}[]{@{}lll@{}}
\toprule
0009 & HORIZONTAL TABULATION & \textbackslash{}t
control-I\tabularnewline
000A & LINE FEED & \textbackslash{}n control-J\tabularnewline
000B & VERTICAL TABULATION & \textbackslash{}v control-K\tabularnewline
000C & FORM FEED & \textbackslash{}f control-L\tabularnewline
000D & CARRIAGE RETURN & \textbackslash{}r control-M\tabularnewline
0020 & SPACE & Zs\tabularnewline
00A0 & NO-BREAK SPACE & Zs\tabularnewline
1680 & OGHAM SPACE MARK & Zs\tabularnewline
2000 & EN QUAD & Zs\tabularnewline
2001 & EM QUAD & Zs\tabularnewline
2002 & EN SPACE & Zs\tabularnewline
2003 & EM SPACE & Zs\tabularnewline
2004 & THREE-PER-EM SPACE & Zs\tabularnewline
2005 & FOUR-PER-EM SPACE & Zs\tabularnewline
2006 & SIX-PER-EM SPACE & Zs\tabularnewline
2007 & FIGURE SPACE & Zs\tabularnewline
2008 & PUNCTUATION SPACE & Zs\tabularnewline
2009 & THIN SPACE & Zs\tabularnewline
200A & HAIR SPACE & Zs\tabularnewline
200B & ZERO WIDTH SPACE & Zs\tabularnewline
2028 & LINE SEPARATOR & Zl\tabularnewline
2029 & PARAGRAPH SEPARATOR & Zp\tabularnewline
202F & NARROW NO-BREAK SPACE & Zs\tabularnewline
3000 & IDEOGRAPHIC SPACE & Zs\tabularnewline
\bottomrule
\end{longtable}

The ASCII whitespace characters are the first six characters in the
above list -- line feed, horizontal tabulation, vertical tabulation,
form feed, carriage return, and space. These are also exactly the
characters recognised by the Posix \texttt{isspace()} procedure. Latin-1
adds the no-break space.

Note: Java's \texttt{isWhitespace()} method is incompatible, including

\begin{longtable}[]{@{}lll@{}}
\toprule
0009 & HORIZONTAL TABULATION & (\textbackslash{}t
control-I)\tabularnewline
001C & FILE SEPARATOR & (control-\textbackslash{})\tabularnewline
001D & GROUP SEPARATOR & (control-{]})\tabularnewline
001E & RECORD SEPARATOR & (control-\^{})\tabularnewline
001F & UNIT SEPARATOR & (control-\_)\tabularnewline
\bottomrule
\end{longtable}

and excluding

\begin{longtable}[]{@{}ll@{}}
\toprule
00A0 & NO-BREAK SPACE\tabularnewline
\bottomrule
\end{longtable}

Java's excluding the no-break space means that tokenizers can simply
break character streams at ``whitespace'' boundaries. However, the
exclusion introduces exceptions in other places, \emph{e.g.}
\texttt{char-set:printing} is no longer simply the union of
\texttt{char-set:graphic} and \texttt{char-set:whitespace.}

\subsection{\texorpdfstring{\href{}{char-set:iso-control}}{char-set:iso-control}}\label{char-setiso-control}

The ISO control characters are the Unicode/Latin-1 characters in the
ranges {[}U+0000,U+001F{]} and {[}U+007F,U+009F{]}.

ASCII restricts this set to the characters in the range
{[}U+0000,U+001F{]} plus the character U+007F.

Note that Unicode defines other control characters which do not belong
to this set (hence the qualifying prefix ``iso-'' in the name). This
restriction is compatible with the Java \texttt{IsISOControl()} method.

\subsection{\texorpdfstring{\href{}{char-set:punctuation}}{char-set:punctuation}}\label{char-setpunctuation}

In Unicode, a punctuation character is any character that has one of the
punctuation categories in the Unicode character database (Pc, Pd, Ps,
Pe, Pi, Pf, or Po.)

ASCII has 23 punctuation characters:

\begin{verbatim}
!"#%&'()*,-./:;?@[\]_{}
\end{verbatim}

Latin-1 adds six more:

\begin{longtable}[]{@{}ll@{}}
\toprule
00A1 & INVERTED EXCLAMATION MARK\tabularnewline
00AB & LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\tabularnewline
00AD & SOFT HYPHEN\tabularnewline
00B7 & MIDDLE DOT\tabularnewline
00BB & RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\tabularnewline
00BF & INVERTED QUESTION MARK\tabularnewline
\bottomrule
\end{longtable}

Note that the nine ASCII characters
\texttt{\$+\textless{}=\textgreater{}\^{}`\textbar{}\textasciitilde{}}
are \emph{not} punctuation. They are ``symbols.''

\subsection{\texorpdfstring{\href{}{char-set:symbol}}{char-set:symbol}}\label{char-setsymbol}

In Unicode, a symbol is any character that has one of the symbol
categories in the Unicode character database (Sm, Sc, Sk, or So). There
are nine ASCII symbol characters:

\begin{verbatim}
$+<=>^`|~
\end{verbatim}

Latin-1 adds 18 more:

\begin{longtable}[]{@{}ll@{}}
\toprule
00A2 & CENT SIGN\tabularnewline
00A3 & POUND SIGN\tabularnewline
00A4 & CURRENCY SIGN\tabularnewline
00A5 & YEN SIGN\tabularnewline
00A6 & BROKEN BAR\tabularnewline
00A7 & SECTION SIGN\tabularnewline
00A8 & DIAERESIS\tabularnewline
00A9 & COPYRIGHT SIGN\tabularnewline
00AC & NOT SIGN\tabularnewline
00AE & REGISTERED SIGN\tabularnewline
00AF & MACRON\tabularnewline
00B0 & DEGREE SIGN\tabularnewline
00B1 & PLUS-MINUS SIGN\tabularnewline
00B4 & ACUTE ACCENT\tabularnewline
00B6 & PILCROW SIGN\tabularnewline
00B8 & CEDILLA\tabularnewline
00D7 & MULTIPLICATION SIGN\tabularnewline
00F7 & DIVISION SIGN\tabularnewline
\bottomrule
\end{longtable}

\subsection{\texorpdfstring{\href{}{char-set:blank}}{char-set:blank}}\label{char-setblank}

Blank chars are horizontal whitespace. In Unicode, a blank character is
either

\begin{itemize}
\tightlist
\item
  a character with the space separator category (Zs) in the Unicode
  character database.
\item
  U+0009 Horizontal tabulation (\textbackslash{}t control-I)
\end{itemize}

There are eighteen blank characters in Unicode 3.0:

\begin{longtable}[]{@{}lll@{}}
\toprule
0009 & HORIZONTAL TABULATION & \textbackslash{}t
control-I\tabularnewline
0020 & SPACE & Zs\tabularnewline
00A0 & NO-BREAK SPACE & Zs\tabularnewline
1680 & OGHAM SPACE MARK & Zs\tabularnewline
2000 & EN QUAD & Zs\tabularnewline
2001 & EM QUAD & Zs\tabularnewline
2002 & EN SPACE & Zs\tabularnewline
2003 & EM SPACE & Zs\tabularnewline
2004 & THREE-PER-EM SPACE & Zs\tabularnewline
2005 & FOUR-PER-EM SPACE & Zs\tabularnewline
2006 & SIX-PER-EM SPACE & Zs\tabularnewline
2007 & FIGURE SPACE & Zs\tabularnewline
2008 & PUNCTUATION SPACE & Zs\tabularnewline
2009 & THIN SPACE & Zs\tabularnewline
200A & HAIR SPACE & Zs\tabularnewline
200B & ZERO WIDTH SPACE & Zs\tabularnewline
202F & NARROW NO-BREAK SPACE & Zs\tabularnewline
3000 & IDEOGRAPHIC SPACE & Zs\tabularnewline
\bottomrule
\end{longtable}

The ASCII blank characters are the first two characters above --
horizontal tab and space. Latin-1 adds the no-break space.

Java doesn't have the concept of ``blank'' characters, so there are no
compatibility issues.

\section{\texorpdfstring{\href{}{Reference
implementation}}{Reference implementation}}\label{reference-implementation}

This SRFI comes with a reference implementation. It resides at:

\url{http://srfi.schemers.org/srfi-14/srfi-14.scm}

I have placed this source on the Net with an unencumbered, ``open''
copyright. Some of the code in the reference implementation bears a
distant family relation to the MIT Scheme implementation, and being
derived from that code, is covered by the MIT Scheme copyright (which is
a generic BSD-style open-source copyright -- see the source file for
details). The remainder of the code was written by myself for scsh or
for this SRFI; I have placed this code under the scsh copyright, which
is also a generic BSD-style open-source copyright.

The code is written for portability and should be simple to port to any
Scheme. It has only the following deviations from R4RS, clearly
discussed in the comments:

\begin{itemize}
\tightlist
\item
  an \texttt{error} procedure;
\item
  the R5RS \texttt{values} procedure for producing multiple return
  values;
\item
  a simple \texttt{check-arg} procedure for argument checking;
\item
  \texttt{let-optionals*} and \texttt{:optional} macros for for parsing,
  checking and defaulting optional arguments from rest lists;
\item
  The SRFI-19 \texttt{define-record-type} form;
\item
  \texttt{bitwise-and} for the hash function;
\item
  \texttt{\%latin1-\textgreater{}char} and
  \texttt{\%char-\textgreater{}latin1}.
\end{itemize}

The library is written for clarity and well-commented; the current
source is about 375 lines of source code and 375 lines of comments and
white space. It is also written for efficiency. Fast paths are provided
for common cases.

This is not to say that the implementation can't be tuned up for a
specific Scheme implementation. There are notes in comments addressing
ways implementors can tune the reference implementation for performance.

In short, I've written the reference implementation to make it as
painless as possible for an implementor -- or a regular programmer -- to
adopt this library and get good results with it.

The code uses a rather simple-minded, inefficient representation for
ASCII/Latin-1 char-sets -- a 256-character string. The character whose
code is i is in the set if s{[}i{]} = ASCII 1 (soh, or \^{}a); not in
the set if s{[}i{]} = ASCII 0 (nul). A much faster and denser
representation would be 16 or 32 bytes worth of bit string. A portable
implementation using bit sets awaits standards for bitwise logical-ops
and byte vectors.

``Large'' character types, such as Unicode, should use a sparse
representation, taking care that the Latin-1 subset continues to be
represented with a dense 32-byte bit set.

\section{\texorpdfstring{\href{}{Acknowledgements}}{Acknowledgements}}\label{acknowledgements}

The design of this library benefited greatly from the feedback provided
during the SRFI discussion phase. Among those contributing thoughtful
commentary and suggestions, both on the mailing list and by private
discussion, were Paolo Amoroso, Lars Arvestad, Alan Bawden, Jim Bender,
Dan Bornstein, Per Bothner, Will Clinger, Brian Denheyer, Kent Dybvig,
Sergei Egorov, Marc Feeley, Matthias Felleisen, Will Fitzgerald, Matthew
Flatt, Arthur A. Gleckler, Ben Goetter, Sven Hartrumpf, Erik Hilsdale,
Shiro Kawai, Richard Kelsey, Oleg Kiselyov, Bengt Kleberg, Donovan
Kolbly, Bruce Korb, Shriram Krishnamurthi, Bruce Lewis, Tom Lord, Brad
Lucier, Dave Mason, David Rush, Klaus Schilling, Jonathan Sobel, Mike
Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald Welsh, and Mike
Wilson. I am grateful to them for their assistance.

I am also grateful the authors, implementors and documentors of all the
systems mentioned in the introduction. Aubrey Jaffer should be noted for
his work in producing Web-accessible versions of the R5RS spec, which
was a tremendous aid.

This is not to imply that these individuals necessarily endorse the
final results, of course.

During this document's long development period, great patience was
exhibited by Mike Sperber, who is the editor for the SRFI, and by
Hillary Sullivan, who is not.

\section{\texorpdfstring{\href{}{References \&
links}}{References \& links}}\label{references-links}

\begin{description}
\tightlist
\item[\textbf{\href{}{{[}Java{]}}} ]
The following URLs provide documentation on relevant Java classes.\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/StringBuffer.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/text/Collator.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/text/package-summary.html}
\item[\textbf{\href{}{{[}MIT-Scheme{]}}} ]
\url{http://www.swiss.ai.mit.edu/projects/scheme/}
\item[\textbf{\href{}{{[}R5RS{]}}}]
Revised\textsuperscript{5} report on the algorithmic language Scheme.\\
R. Kelsey, W. Clinger, J. Rees (editors).\\
Higher-Order and Symbolic Computation, Vol. 11, No. 1, September,
1998.\\
and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998.\\
Available at \url{http://www.schemers.org/Documents/Standards/}.
\item[\textbf{{[}SRFI{]}}]
The SRFI web site.\\
\url{http://srfi.schemers.org/}
\item[\textbf{{[}SRFI-14{]}}]
SRFI-14: String libraries.\\
\url{http://srfi.schemers.org/srfi-14/}

\begin{description}
\tightlist
\item[ This document, in HTML: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14.html}
\item[ This document, in plain text format: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14.txt}
\item[ Source code for the reference implementation: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14.scm}
\item[ Scheme 48 module specification, with typings: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14-s48-module.scm}
\item[ Regression-test suite: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14-tests.scm}
\end{description}
\item[\textbf{\href{}{{[}Unicode{]}}} ]
\url{http://www.unicode.org/}
\item[\textbf{\href{}{{[}UnicodeData{]}}} ]
The Unicode character database.\\
\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}\\
\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}
\end{description}

\section{\texorpdfstring{\href{}{Copyright}}{Copyright}}\label{copyright}

Certain portions of this document -- the specific, marked segments of
text describing the \protect\hyperlink{R5RS}{R5RS} procedures -- were
adapted with permission from the R5RS report.

All other text is copyright (C) Olin Shivers (1998, 1999, 2000). All
Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
